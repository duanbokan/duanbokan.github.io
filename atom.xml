<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沙僧</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-19T07:16:47.224Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>沙僧</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter状态管理</title>
    <link href="http://example.com/2022/04/19/Flutter%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2022/04/19/Flutter%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/</id>
    <published>2022-04-19T06:54:46.000Z</published>
    <updated>2022-04-19T07:16:47.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flutter状态管理"><a href="#Flutter状态管理" class="headerlink" title="Flutter状态管理"></a>Flutter状态管理</h2><p>在响应式编程中，状态即数据，状态变化，页面即发生变化，Flutter作为响应式开发框架，状态管理是Flutter开发过程中代码架构的重点，本文中，我们将通过分析常用的Flutter状态管理框架，给大家深入解析状态管理的核心实现方法，方便大家在后续开发中，挑选合适的状态管理框架。</p><p>Flutter本身已经给我们提供了一个状态管理方式，即Flutter自带的StatefulWidget，但是我们在应用过程中，会发现，这个状态仅仅适合在单个StatefulWidget中进行维护，当我们需要一个跨组件状态时，StatefulWidget将不再是一个好的选择，虽然我们可以使用callBack进行解决，但这个方式一旦业务增长到一定程度，嵌套较深的时候，将会造成很大的代码耦合，因此，我们需要使用一个状态管理组件进行维护这些状态。</p><p>常用的状态管理组件，包含了ScopedModel，BLoC，RxDart，Provider等，今天我们将在这里对这些状态管理机制的使用方法及原理进行剖析。</p><h3 id="一、-状态管理分类："><a href="#一、-状态管理分类：" class="headerlink" title="一、 状态管理分类："></a>一、 状态管理分类：</h3><p>首先，常用的状态管理，按照范围可以划分为局部状态管理和全局状态管理：</p><h4 id="局部状态："><a href="#局部状态：" class="headerlink" title="局部状态："></a>局部状态：</h4><p>Flutter提供了类似StatefulWidget、InheritWidget组件来实现局部状态管理，当这些Widget发生变化时，所有子树中依赖其数据的widget都会进行rebuild。</p><h4 id="全局状态："><a href="#全局状态：" class="headerlink" title="全局状态："></a>全局状态：</h4><p>Flutter没有提供原生的全局状态管理机制，虽然可以在根布局控件使用InheritWidget来实现全局状态管理，但是这样会存在类似依赖传递过深等问题。因此大多数情况下，需要依赖一些第三方库实现全局状态管理</p><h4 id="最简单的状态管理"><a href="#最简单的状态管理" class="headerlink" title="最简单的状态管理"></a>最简单的状态管理</h4><p>我们可以使用 State + InheritedWidget实现最简单的状态管理机制。</p><h3 id="二、-状态管理——Stream"><a href="#二、-状态管理——Stream" class="headerlink" title="二、 状态管理——Stream"></a>二、 状态管理——Stream</h3><p>Stream在Flutter中标志着的事件流或者管道一类的概念，通过Stream可以快速的实现给予事件流驱动的业务逻辑。界面通过订阅事件，并针对各个事件进行变化处理，实现响应式更新界面。 </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">展示文本</span></span></span><br><span class="line"><span class="built_in">String</span> textString = <span class="string">&quot;等待接收文本&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">单订阅Stream</span></span></span><br><span class="line">Stream&lt;<span class="built_in">String</span>&gt; stream = <span class="keyword">new</span> Stream.fromFuture(_doFutureTask());</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> initState() &#123;</span><br><span class="line">StreamSubscription subscription = stream.listen((data) &#123;</span><br><span class="line">  textString = data;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;接收数据成功&quot;</span>);</span><br><span class="line">&#125;, onDone: () &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;流处理完成&quot;</span>);</span><br><span class="line">&#125;, onError: () &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;流处理出现异常&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Subscription<span class="emphasis">_API</span></span></span></span><br><span class="line">subscription.cancel();</span><br><span class="line">subscription.pause();</span><br><span class="line">subscription.resume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">异步任务</span></span></span></span><br><span class="line"><span class="keyword">static</span> _doFutureTask() &#123;</span><br><span class="line"><span class="keyword">return</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">5</span>), () &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是一个最简单的，通过异步任务创建流对象的方法，包含了流的创建、监听、管理，Stream流，分为单订阅流和广播流</p><h4 id="单订阅流"><a href="#单订阅流" class="headerlink" title="单订阅流"></a>单订阅流</h4><p>单订阅流只允许在该Stream的整个生命周期，注册一个监听器，即使第一个监听器被取消了，也无法在这个时间流中，监听到第二次事件。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">StreamController&lt;<span class="built_in">String</span>&gt; singleStream = StreamController();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息发送</span></span><br><span class="line">singleStream.add(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用过程中，经常会在log平台输出： Bad state: Stream has already been listened to.<br>其含义就是指：单订阅流不能有多个收听者</p><h4 id="广播流"><a href="#广播流" class="headerlink" title="广播流"></a>广播流</h4><p>广播流，和单订阅流不同，允许任意个数的监听者，可以随时随地为其添加监听器，只要新的监听器，被添加进去，就可以收到新的事件</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">StreamController&lt;<span class="built_in">int</span>&gt; singleStream = StreamController.broadcast();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息发送</span></span><br><span class="line">singleStream.sink.add(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>StreamController的构造函数是一个泛型，意味着StreamController可以往流上推送任意类型的数据，当然这里需要考虑接收时候的数据类型处理。</p><h4 id="StreamBuilder如何实现刷新"><a href="#StreamBuilder如何实现刷新" class="headerlink" title="StreamBuilder如何实现刷新"></a>StreamBuilder如何实现刷新</h4><p>在上边的例子中，我们看到了在页面中有使用一个StreamBuilder，来构建一个UI展示：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">StreamBuilder&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">        builder: (context, snapshot) &#123;</span><br><span class="line">          <span class="keyword">if</span> (snapshot == <span class="keyword">null</span> || !snapshot.hasData) &#123;</span><br><span class="line">            <span class="keyword">return</span> CircularProgressIndicator();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (snapshot.hasError) &#123;</span><br><span class="line">              <span class="keyword">return</span> Text(<span class="string">&quot;发生错误&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> Text(snapshot.data);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        stream: singleStream.stream,</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><p>那么StreamBuilder和Widget的刷新，是怎么关联起来的呢？通过阅读代码，我们发现，其实StreamBuilder的主要逻辑在_StreamBuilderBaseState中，_StreamBuilderBaseState在initState、didUpdateWidget中会调用_subscribe方法，从而调用Stream的listen，然后通过setState更新UI。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _subscribe() &#123;</span><br><span class="line"><span class="keyword">if</span> (widget.stream != <span class="keyword">null</span>) &#123;</span><br><span class="line">  _subscription = widget.stream.listen((T data) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _summary = widget.afterData(_summary, data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, onError: (<span class="built_in">Object</span> error) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _summary = widget.afterError(_summary, error);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, onDone: () &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _summary = widget.afterDone(_summary);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  _summary = widget.afterConnected(_summary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  }</p><p>而setState的刷新机制，其实我们大家应该都知道，实质上是调用了markNeedsBuild，markNeedsBuild方法会标记element为dirty，这样在下一帧WidgetsBinding.drawFrame的时候，会进行绘制</p><h4 id="StreamController整体架构"><a href="#StreamController整体架构" class="headerlink" title="StreamController整体架构"></a>StreamController整体架构</h4><p>从上边几个demo中，我们看到Flutter的Stream流中，存在Stream、StreamController、Sink、以及StreamSubscription这样四个比较关键的组件，那么这四个组件是以一个什么样子的形式互相结合起来的呢。我们通过下边这样一副图，进行说明：</p><p><img src="http://image.jucaiwy.com/image/20220419/stream_pic.png"></p><p>整个流程，概括起来就是：StreamController作为一个统筹管理的“Boss”，主要负责协调和维护整个事件流的输入和输出，StreamController暴露了一个Sink属性，主要负责事件流的输入，在这里输入事件。暴露一个Stream属性，主要负责流事件的输出，除自身提供了事件转换方法，例如where、take等，主要进行事件流的转换。同时，Stream对外提供了事件的监听，分别可以处理在收到事件以后的处理onData，事件处理完成以后的onDone以及事件处理异常的onError等方法，通过注册这样的监听，我们又可以得到StreamSubscription这个属性，其功能，主要管理事件的订阅，包含取消、暂停、恢复等操作</p><h4 id="StreamController同步、异步处理"><a href="#StreamController同步、异步处理" class="headerlink" title="StreamController同步、异步处理"></a>StreamController同步、异步处理</h4><p>在初始化StreamController的时候，我们可以看到，有一个构造参数，sync，针对我们传递的sync值，决定使用同步流还是异步流。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">sync</span></span><br><span class="line">    ? <span class="keyword">new</span> _SyncStreamController&lt;T&gt;(onListen, onPause, onResume, onCancel)</span><br><span class="line">    : <span class="keyword">new</span> _AsyncStreamController&lt;T&gt;(onListen, onPause, onResume, onCancel);</span><br></pre></td></tr></table></figure><p>这里具体怎么实现的呢，我们一起来看一下。在同步流中，直接调用了subscription的_add方法，直接将数据添加进事件回掉监听中，实现同步：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _sendData(T data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_isEmpty) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (_hasOneListener) &#123;</span><br><span class="line">      _state |= _BroadcastStreamController._STATE_FIRING;</span><br><span class="line">      _BroadcastSubscription&lt;T&gt; subscription = _firstSubscription;</span><br><span class="line">      subscription._add(data);</span><br><span class="line">      _state &amp;= ~_BroadcastStreamController._STATE_FIRING;</span><br><span class="line">      <span class="keyword">if</span> (_isEmpty) &#123;</span><br><span class="line">        _callOnCancel();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _forEachListener((_BufferingStreamSubscription&lt;T&gt; subscription) &#123;</span><br><span class="line">         subscription._add(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<br>而在异步流中，则是使用_addPending方法，添加了一个继承自_DelayedEvent的方法，实现异步：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">_AsyncStreamControllerDispatch</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">_StreamController</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">void</span> _sendData(T data) &#123;</span><br><span class="line">_subscription._addPending(<span class="keyword">new</span> _DelayedData&lt;T&gt;(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _sendError(<span class="built_in">Object</span> error, StackTrace stackTrace) &#123;</span><br><span class="line">    _subscription._addPending(<span class="keyword">new</span> _DelayedError(error, stackTrace));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _sendDone() &#123;</span><br><span class="line">    _subscription._addPending(<span class="keyword">const</span> _DelayedDone());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么Flutter是怎么实现异步的呢。我们继续深入挖掘，发现在异步任务中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> schedule(_EventDispatch&lt;T&gt; dispatch) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isScheduled) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">assert</span>(!isEmpty);</span><br><span class="line">    <span class="keyword">if</span> (_eventScheduled) &#123;</span><br><span class="line">      <span class="keyword">assert</span>(_state == _STATE_CANCELED);</span><br><span class="line">      _state = _STATE_SCHEDULED;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    scheduleMicrotask(() &#123;</span><br><span class="line">      <span class="built_in">int</span> oldState = _state;</span><br><span class="line">      _state = _STATE_UNSCHEDULED;</span><br><span class="line">      <span class="keyword">if</span> (oldState == _STATE_CANCELED) <span class="keyword">return</span>;</span><br><span class="line">      handleNext(dispatch);</span><br><span class="line">    &#125;);</span><br><span class="line">    _state = _STATE_SCHEDULED;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>因此，Flutter异步任务执行，实际上相当于在Microtask任务队列里边添加了一个任务，而我们都知道，Flutter为单线程应用，和大多数单线程应用一样，通过消息循环机制来运行，这个机制中，主要包含了两个任务队列，一个是microtask内部队列，一个是event外部队列，而microtask的优先级又高于event。Stream通过这样的方式实现了异步</p><p><img src="http://image.jucaiwy.com/image/20220419/flutter_thread.png"></p><p>至此，我们已经基本了解了Stream的原理及一些常用的api，这方便我们对后续的RxDart、Provider等进行分析</p><h3 id="三、状态管理——RxDart"><a href="#三、状态管理——RxDart" class="headerlink" title="三、状态管理——RxDart"></a>三、状态管理——RxDart</h3><p>说到RxDart就不得不提一下ReactiveX，<a href="http://reactivex.io/">http://reactivex.io/</a>  </p><p>在其官网上，对ReactiveX的介绍为</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“An API <span class="keyword">for</span> asynchronous programming <span class="keyword">with</span> observable streams”</span><br></pre></td></tr></table></figure><p>用于可观察流的异步编程的API，一句话概括了ReactiveX的核心设计思想，为各个平台提供了异步编程的可观察流API。当然在Dart上也不例外。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">创建一个Subject</span></span></span><br><span class="line"><span class="keyword">var</span> subject = PublishSubject&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">通过listen实现订阅</span></span></span><br><span class="line">subject.listen((<span class="built_in">String</span> data) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;OnData &quot;</span> + data);</span><br><span class="line">&#125;, onError: () &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;onError &quot;</span>);</span><br><span class="line">&#125;, onDone: () &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;onDone &quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">使用完成，关闭</span></span></span><br><span class="line">subject.close();</span><br></pre></td></tr></table></figure><p>这里是一个最简单的RxDart的使用方法，细心的同学可能已经发现了，这不就是之前的StreamController么。的确是这样的，RxDart内部，其实也是对Stream的一个封装。PublishSubject的内部实现，其实也是一个广播类型的StreamController：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">factory</span> PublishSubject(&#123;<span class="keyword">void</span> onListen(), <span class="keyword">void</span> onCancel(), <span class="built_in">bool</span> <span class="keyword">sync</span> = <span class="keyword">false</span>&#125;) &#123;</span><br><span class="line">    <span class="comment">// ignore: close_sinks</span></span><br><span class="line">    <span class="keyword">final</span> controller = StreamController&lt;T&gt;.broadcast(</span><br><span class="line">      onListen: onListen,</span><br><span class="line">      onCancel: onCancel,</span><br><span class="line">      <span class="keyword">sync</span>: <span class="keyword">sync</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PublishSubject&lt;T&gt;._(</span><br><span class="line">      controller,</span><br><span class="line">      Observable&lt;T&gt;(controller.stream),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们也明白了：</p><ol><li><p>在RxDart中Subject，无论是PublishSubject还是BehaviorSubject(只保留最后一个值的特殊流)，其核心其实还是StreamController</p></li><li><p>RxDart中的Observable实质上相当于一个Stream</p></li></ol><p>总结一下，RxDart，实际是对上边所说的Stream进行了概念转换，变成了ReactiveX用户熟悉的对象和操作符，本质上还是一个Stream，这也是为什么可以直接在StreamBuilder中使用RxDart。</p><h3 id="四、状态管理——Provider"><a href="#四、状态管理——Provider" class="headerlink" title="四、状态管理——Provider"></a>四、状态管理——Provider</h3><p>Provider是Flutter官方推荐的状态管理方式之一，它的特点是，不复杂，好理解，可控度较高。</p><h4 id="Provider使用"><a href="#Provider使用" class="headerlink" title="Provider使用"></a>Provider使用</h4><p>第一步添加依赖</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">provider: ^<span class="number">2.0</span><span class="number">.1</span>+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>第二步  创建数据模型</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">计数module</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterModel</span> <span class="keyword">extends</span> <span class="title">ChangeNotifier</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">计数</span></span></span><br><span class="line">  <span class="built_in">int</span> _count = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> value =&gt; _count;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> increment() &#123;</span><br><span class="line">    _count++;</span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该Module继承自ChangeNotifier，主要负责数据模型保存和管理，同时暴露出来的notifyListeners()方法，在调用后，可以自动更新其所有的监听者。</p><p>第三步  创建全局共享数据依赖</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">数据模型</span></span></span><br><span class="line">  <span class="keyword">final</span> counter = CounterModel();</span><br><span class="line">  </span><br><span class="line">  runApp(</span><br><span class="line">    ChangeNotifierProvider.value(</span><br><span class="line">      notifier: counter,</span><br><span class="line">      child: MyApp(),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      theme: ThemeData.dark(),</span><br><span class="line">      home: FirstScreen(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们使用ChangeNotifierProvider，并设置其value为之前创建的数据模型。ChangeNotifierProvider<T>.value类型的数据，不仅可以将数据共享给其所有的子节点进行使用，同时还可以在数据发生变化时，通过调用之前数据模型中的notifyListeners()方法进行刷新。</p><p>第四步  在其他页面中获取共享的状态</p><p>这里我们通过两个页面，相互之间共同持有一份数据的例子，来看看Provider是怎么处理两个页面之间数据的共享的，首先我们创建第一个页面</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Provider 页面</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Provider &quot;</span> + <span class="string">&quot;FirstScreen build&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> _counter = Provider.of&lt;CounterModel&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">&#x27;FirstPage&#x27;</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">          child: GestureDetector(</span><br><span class="line">              onTap: () =&gt; &#123;_counter.increment()&#125;,</span><br><span class="line">              child: Text(</span><br><span class="line">                <span class="string">&#x27;Value: <span class="subst">$&#123;_counter.value&#125;</span>&#x27;</span>,</span><br><span class="line">                style: TextStyle(fontSize: <span class="number">48</span>),</span><br><span class="line">              ))),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: () =&gt; Navigator.of(context)</span><br><span class="line">            .push(MaterialPageRoute(builder: (context) =&gt; SecondPage())),</span><br><span class="line">        child: Icon(Icons.navigate_next),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个页面中，我们使用Provider.of<T>(context)方法来向上寻找最近存储了T的祖先节点数据。我们这里获取到了存储的CounterModel，并对其属性value进行展示。然后在点击文本的时候，自增，希望在第二个页面中，可以拿到并展示。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Provider 页面</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext buildContext) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Provider &quot;</span> + <span class="string">&quot;SecondPage build&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">&#x27;Second Page&#x27;</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Consumer&lt;CounterModel&gt;(</span><br><span class="line">          builder: (context, CounterModel counter, _) =&gt; Center(</span><br><span class="line">              child: GestureDetector(</span><br><span class="line">                  onTap: () =&gt; &#123;counter.increment()&#125;,</span><br><span class="line">                  child: Text(</span><br><span class="line">                    <span class="string">&#x27;Value: <span class="subst">$&#123;counter.value&#125;</span>&#x27;</span>,</span><br><span class="line">                    style: TextStyle(</span><br><span class="line">                      fontSize: <span class="number">48</span>,</span><br><span class="line">                    ),</span><br><span class="line">                  ))),</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第二个页面中，我们并没有像在第一个页面中一样，使用Provider.of<T>(context)方式去获取Provider中共享的数据，而是使用了Consumer这个方式去获取，这两个有什么不一样呢，先看完演示结果，然后继续往下分析。</p><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>在上边的例子中，我们使用了Consumer获取Provider中共享的数据模型，Consumer使用了Builder模式，收到更新通知就会通过builder重新构建。Consumer<T>代表了它要获取哪一个祖先中的Model。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Widget <span class="built_in">Function</span>(BuildContext context, T value, Widget child) builder;</span><br></pre></td></tr></table></figure><p>从Consumer的构造方法中，我们可以看到，其builder实际上就是一个Funcation，它接受三个参数，用于构建自身。同样原理的还有Consumer2，和Consumer类似，只是入参的泛型，变成了两个：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Widget <span class="built_in">Function</span>(BuildContext context, A value, B value2, Widget child) builder;</span><br></pre></td></tr></table></figure><p>其实在源码中，这里最多可以到6个，大家在使用的过程中，可以根据自己需要进行选取。</p><p>那么为什么需要区分这两个获取数据类型的方法呢，我们在上述两个页面的build方法中，分别添加了log，进行日志打印，操作步骤为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 进入第一个页面，点击两次Value，使数据自增</span><br><span class="line"><span class="number">2.</span> 点击进入下一个页面</span><br><span class="line"><span class="number">3.</span> 在第二个页面，同样点击两次Value，使数据自增</span><br><span class="line"><span class="number">4.</span> 返回第一个页面，点击一次Value，自增</span><br></pre></td></tr></table></figure><p>​<br>我们可以看到Log打印如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-12</span><span class="number">-12</span> <span class="number">18</span>:<span class="number">30</span>:<span class="number">26.873</span> <span class="number">4273</span><span class="number">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br><span class="line"><span class="number">2020</span><span class="number">-12</span><span class="number">-12</span> <span class="number">18</span>:<span class="number">30</span>:<span class="number">27.777</span> <span class="number">4273</span><span class="number">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br><span class="line"><span class="number">2020</span><span class="number">-12</span><span class="number">-12</span> <span class="number">18</span>:<span class="number">30</span>:<span class="number">29.290</span> <span class="number">4273</span><span class="number">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider SecondPage build</span><br><span class="line"><span class="number">2020</span><span class="number">-12</span><span class="number">-12</span> <span class="number">18</span>:<span class="number">30</span>:<span class="number">30.203</span> <span class="number">4273</span><span class="number">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br><span class="line"><span class="number">2020</span><span class="number">-12</span><span class="number">-12</span> <span class="number">18</span>:<span class="number">30</span>:<span class="number">31.726</span> <span class="number">4273</span><span class="number">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br><span class="line"><span class="number">2020</span><span class="number">-12</span><span class="number">-12</span> <span class="number">18</span>:<span class="number">30</span>:<span class="number">35.223</span> <span class="number">4273</span><span class="number">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br></pre></td></tr></table></figure><p>可以看到使用Provider.of<T>(context)的第一个页面，在每一次点击按钮的时候，都会重新build，而页面二，则没有。也就是说，使用Consumer进行数据共享的时候，仅仅只更新自身的Widget。那么为什么Consumer可以做到局部更新呢，我们来看一下Consumer的内部构造：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> builder(</span><br><span class="line">      context,</span><br><span class="line">      Provider.of&lt;T&gt;(context),</span><br><span class="line">      child,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>也就是在Consumer中，实际上，也是通过使用Provider.of<T>(context),来实现的。那么问题就来了，同样是Provider.of<T>(context)实现的，为什么Consumer就可以实现局部刷新呢？</p><p>这里我们可以看一下在第二个页面中，我们在构建Consumer的时候，传递的context，并不是Widget中build方法提供的buildContext，而是使用了自己的context，所以在刷新的时候，可以做到局部刷新，这样就方便我们在Flutter开发的时候，使用局部刷新进行页面性能优化。</p><p><img src="http://image.jucaiwy.com/image/20220419/flutter_state_code.png"></p><p>至此，我们已经基本上了解到了Provider的基础用法，当然Provider还提供了核心的dispose方法，方便用户进行回收，这里因为还没有彻底搞清楚，所以暂不进行介绍。</p><p>Provider还有更多，更详尽的用法，比如 ValueListenableProvider、FutureProvider、StreamProvider等多种Provider，可见整个Provider的设计上更贴近Flutter的原生特性，同时设计也更好理解，并且兼顾了性能等问题。这些后边在使用到的时候，我们在进行逐步分析和解析</p><h3 id="五、-总结"><a href="#五、-总结" class="headerlink" title="五、 总结"></a>五、 总结</h3><p>总结上述所有的状态管理机制，无论是Flutter原生提供的Stream，还是ReactiveX提供的RxDart，亦或是Provider，以及没有在文章中出现的scoped_model、阿里开源的fish_redux，这一系列的组件，都为我们提供了一个很好的状态管理机制，而我们在使用过程中，大可通过自身业务需求，按需选型。</p><p>​</p>]]></content>
    
    
    <summary type="html">Flutter—状态管理机制</summary>
    
    
    
    <category term="Flutter" scheme="http://example.com/categories/Flutter/"/>
    
    
    <category term="Flutter" scheme="http://example.com/tags/Flutter/"/>
    
    <category term="状态管理" scheme="http://example.com/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    
    <category term="Provider" scheme="http://example.com/tags/Provider/"/>
    
    <category term="Stream" scheme="http://example.com/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>Flutter—Json数据格式化</title>
    <link href="http://example.com/2019/11/28/20191128Flutter%E2%80%94Json%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <id>http://example.com/2019/11/28/20191128Flutter%E2%80%94Json%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96/</id>
    <published>2019-11-28T06:54:46.000Z</published>
    <updated>2022-04-19T07:13:28.477Z</updated>
    
    <content type="html"><![CDATA[<p>因为Flutter中禁止使用运行时反射，因为运行时反射回干扰Dart的<strong>tree shaking</strong>(具体是什么，我也不知道)，所以之前在Java中使用Gson等序列化工具，无法在Flutter中正常使用。同样的道理，Dart中支持的dartson，也是使用了运行时反射，所以也不能在Flutter中使用。</p><p>在Flutter中，我们一般使用自动化源码生成器<a href="https://pub.dartlang.org/packages/json_serializable"> json_serializable package </a>包，在开发阶段，生成Json序列化和反序列化的模版。具体使用方式如下：</p><h3 id="1-在项目中配置json-serializable的依赖"><a href="#1-在项目中配置json-serializable的依赖" class="headerlink" title="1. 在项目中配置json_serializable的依赖"></a>1. 在项目中配置json_serializable的依赖</h3><p>想将json_serializable引入到我们的项目中，需要完成两个依赖，一个是开发依赖，一个是常规依赖，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  # Your other regular dependencies here</span><br><span class="line">  json_annotation: ^<span class="number">2.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">dev_dependencies:</span><br><span class="line">  # Your other dev_dependencies here</span><br><span class="line">  build_runner: ^<span class="number">1.1</span><span class="number">.3</span></span><br><span class="line">  json_serializable: ^<span class="number">2.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>配置完成以后，需要执行** flutter packages get **命令进行相关依赖包的导入。</p><h3 id="2-以json-serializable的方式创建Model类"><a href="#2-以json-serializable的方式创建Model类" class="headerlink" title="2. 以json_serializable的方式创建Model类"></a>2. 以json_serializable的方式创建Model类</h3><p>使用json_serializable方式创建Model类，可以按照以下几步进行操作：</p><h4 id="2-1-创建Model类文件-test-user-dart"><a href="#2-1-创建Model类文件-test-user-dart" class="headerlink" title="2.1 创建Model类文件 test_user.dart"></a>2.1 创建Model类文件 test_user.dart</h4><h4 id="2-2-创建Model类，包含相关字段。"><a href="#2-2-创建Model类，包含相关字段。" class="headerlink" title="2.2 创建Model类，包含相关字段。"></a>2.2 创建Model类，包含相关字段。</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">用户信息</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 名字</span></span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 年龄</span></span><br><span class="line">  <span class="built_in">int</span> userAge;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否结婚</span></span><br><span class="line">  <span class="built_in">bool</span> isMarried;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-给Model类添加json-serializable的注解-JsonSerializable"><a href="#2-3-给Model类添加json-serializable的注解-JsonSerializable" class="headerlink" title="2.3 给Model类添加json_serializable的注解@JsonSerializable()"></a>2.3 给Model类添加json_serializable的注解@JsonSerializable()</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:json_annotation/json_annotation.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">用户信息</span></span></span><br><span class="line"><span class="meta">@JsonSerializable</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 名字</span></span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 年龄</span></span><br><span class="line">  <span class="built_in">int</span> userAge;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否结婚</span></span><br><span class="line">  <span class="built_in">bool</span> isMarried;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-代码引入part，引入fromJson和toJson方法"><a href="#2-4-代码引入part，引入fromJson和toJson方法" class="headerlink" title="2.4 代码引入part，引入fromJson和toJson方法"></a>2.4 代码引入part，引入fromJson和toJson方法</h4><p>这里part好像是需要自己手动写上，还有下边的fromJson和toJson方法也是需要自己进行手动添加，不知道是否有快捷键，没找到，暂且手写吧。</p><p><strong>这里需要注意的是，一定要添加默认构造方法，否则会编译不通过。</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:json_annotation/json_annotation.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">part</span> <span class="string">&#x27;test_user.g.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">用户信息</span></span></span><br><span class="line"><span class="meta">@JsonSerializable</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 名字</span></span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 年龄</span></span><br><span class="line">  <span class="built_in">int</span> userAge;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否结婚</span></span><br><span class="line">  <span class="built_in">bool</span> isMarried;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认构造函数</span></span><br><span class="line">  UserInfo(<span class="keyword">this</span>.name, <span class="keyword">this</span>.userAge, <span class="keyword">this</span>.isMarried);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> UserInfo.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; json) =&gt;</span><br><span class="line">      _$UserInfoFromJson(json);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; toJson() =&gt; _$UserInfoToJson(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>加入这些方法后，发现新加入的part以及fromJson及toJson方法无法找到，这时候我们需要使用<strong>flutter packages</strong>命令进行生成相应的test_user.g.dart类。</p><p>这里可以使用单次build命令进行生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages pub run build_runner build</span><br></pre></td></tr></table></figure><p>也可以使用watch模式，进行监控生成，在所有的JsonBean对象都生成以后，使用control+c退出命令行模式，会生成相对应的.g.dart文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages pub run build_runner build</span><br></pre></td></tr></table></figure><p>此时，之前新建的<strong>test_user.dart</strong>同级目录下，会生成之前part中输入的<strong>test_user.g.dart</strong>文件，截止目前，Flutter可以使用的Json序列化对象，已经构建完成。</p><h3 id="3-FlutterJson对象使用方法"><a href="#3-FlutterJson对象使用方法" class="headerlink" title="3. FlutterJson对象使用方法"></a>3. FlutterJson对象使用方法</h3><p>使用时，直接可以使用UserInfo.fromJson，进行json解析，或者是userInfo.toJson，进行json序列化。需要注意以下几点：</p><pre><code>1. Flutter中json将数据格式比较严格，不像Gson中，double的值，也可使用String去解析，必须一一对应。2. 需要解析的对象中，如果有定义了一个服务端么有下发的bool值，并赋初始值为false时，经过json解析后，为null。没明白为啥，但是的确是这样子，bool可以为bull</code></pre><p><img src="http://image.jucaiwy.com/image/20191128/flutter_json.jpeg"></p>]]></content>
    
    
    <summary type="html">Flutter—Json数据格式化</summary>
    
    
    
    <category term="Flutter" scheme="http://example.com/categories/Flutter/"/>
    
    
    <category term="Flutter" scheme="http://example.com/tags/Flutter/"/>
    
    <category term="Json" scheme="http://example.com/tags/Json/"/>
    
    <category term="序列化和反序列化" scheme="http://example.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>AndroidStudio集成ReactNative到已有工程</title>
    <link href="http://example.com/2018/01/04/20180104%E9%9B%86%E6%88%90ReactNative%E5%88%B0%E5%B7%B2%E6%9C%89%E5%B7%A5%E7%A8%8B/"/>
    <id>http://example.com/2018/01/04/20180104%E9%9B%86%E6%88%90ReactNative%E5%88%B0%E5%B7%B2%E6%9C%89%E5%B7%A5%E7%A8%8B/</id>
    <published>2018-01-04T11:34:46.000Z</published>
    <updated>2020-12-09T06:36:49.320Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看ReactNative的教程，书本上都是直接npm init出来的一个个工程，我突发奇想，觉得直接继承到现有的app里边比较方便开发，说干就干，在网上查了不少资料，也跳了不少坑，现在把我搭建环境的步骤记录下来，方便以后查看</p><h3 id="1-新建AndroidStudio工程"><a href="#1-新建AndroidStudio工程" class="headerlink" title="1. 新建AndroidStudio工程"></a>1. 新建AndroidStudio工程</h3><p>首先需要新建AndroidStudio工程，注意使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compileSdkVersion 23</span><br><span class="line">minSdkVersion 16</span><br><span class="line">targetSdkVersion 23</span><br></pre></td></tr></table></figure><p>以及依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &#x27;com.android.support:appcompat-v7:23.0.1&#x27;</span><br></pre></td></tr></table></figure><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h3><p>打开AndroidStudio底部的Terminal，然后再命令行模式下，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="http://image.jucaiwy.com/image/20180104/EXnbv92.png"></p><p>然后，一路回车，会生成 package.json文件</p><p><img src="http://image.jucaiwy.com/image/20180104/q0oJTnh.png"></p><h3 id="3-安装node-module"><a href="#3-安装node-module" class="headerlink" title="3. 安装node-module"></a>3. 安装node-module</h3><p>继续在AndroidStudio底部的Terminal中，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react react-native</span><br></pre></td></tr></table></figure><p>然后，回车，大一一分多钟以后，会在工程目录中看到 node_modules 这个包，表示安装成功</p><p>安装中：</p><p><img src="http://image.jucaiwy.com/image/20180104/3B4dP8p.png"></p><p>安装成功：</p><p><img src="http://image.jucaiwy.com/image/20180104/QGitFFv.png"></p><h3 id="4-下载-flowconfig"><a href="#4-下载-flowconfig" class="headerlink" title="4. 下载.flowconfig"></a>4. 下载.flowconfig</h3><p>可以使用命令下载这个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o .flowconfig https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig</span><br></pre></td></tr></table></figure><p>或者直接在根目录中新建文档：.flowconfig,然后复制以下文本，在这个文件中进行保存</p><p><a href="https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig">https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig</a></p><h3 id="5-添加index-android-js"><a href="#5-添加index-android-js" class="headerlink" title="5. 添加index.android.js"></a>5. 添加index.android.js</h3><p>这里我们使用index.android.js为ReactNative的界面入口，也是展示HelloWord的js界面，我们可以直接在工程根目录下创建index.android.js文件，代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123;</span><br><span class="line">    AppRegistry,</span><br><span class="line">    StyleSheet,</span><br><span class="line">    Text,</span><br><span class="line">    View</span><br><span class="line">&#125; from &#x27;react-native&#x27;;</span><br><span class="line"></span><br><span class="line">class HelloWorldApp extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">                &lt;Text style=&#123;styles.hello&#125;&gt;Hello world! I am from ReactNattive!!&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var styles = StyleSheet.create(&#123;</span><br><span class="line">    container: &#123;</span><br><span class="line">        flex: 1,</span><br><span class="line">        justifyContent: &#x27;center&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">    hello: &#123;</span><br><span class="line">        fontSize: 20,</span><br><span class="line">        textAlign: &#x27;center&#x27;,</span><br><span class="line">        margin: 10,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(&#x27;ReactNative&#x27;, () =&gt; HelloWorldApp);</span><br></pre></td></tr></table></figure><p>这里需要注意最后一行代码，registerComponent，这里的第一个参数，必须和自己新建的Android项目名称一样，我们的项目名称是ReactNative，所以第一个参数应该是ReactNative，第二个参数和index.android.js中定义的方法名一样。</p><p>所有的文件添加完成后，整个包是这样的：</p><p><img src="http://image.jucaiwy.com/image/20180104/7zODqQG.png"></p><h3 id="6-App添加依赖"><a href="#6-App添加依赖" class="headerlink" title="6. App添加依赖"></a>6. App添加依赖</h3><p>首先需要再ReactNative项目app模块的build.gradle目录中添加react-native依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &quot;com.facebook.react:react-native:+&quot;</span><br></pre></td></tr></table></figure><p>添加完成后，完整的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#x27;com.android.application&#x27;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 23</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId &quot;jd.com.react&quot;</span><br><span class="line">        minSdkVersion 16</span><br><span class="line">        targetSdkVersion 23</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line">        // 开始修改java.lang.UnsatisfiedLinkError: dlopen failed: &quot;/data/data/com.snapdeal.main/lib-main/libgnustl_shared.so&quot; is 32-bit instead of 64-bit</span><br><span class="line">        ndk &#123;</span><br><span class="line">            abiFilters &quot;armeabi-v7a&quot;, &quot;x86&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        packagingOptions &#123;</span><br><span class="line">            exclude &quot;lib/arm64-v8a/librealm-jni.so&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        // 结束修改java.lang.UnsatisfiedLinkError: dlopen failed: &quot;/data/data/com.snapdeal.main/lib-main/libgnustl_shared.so&quot; is 32-bit instead of 64-bit</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&#x27;proguard-android.txt&#x27;), &#x27;proguard-rules.pro&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(include: [&#x27;*.jar&#x27;], dir: &#x27;libs&#x27;)</span><br><span class="line">    implementation &#x27;com.android.support:appcompat-v7:23.0.1&#x27;</span><br><span class="line">    implementation &#x27;com.android.support.constraint:constraint-layout:1.0.2&#x27;</span><br><span class="line">    testImplementation &#x27;junit:junit:4.12&#x27;</span><br><span class="line"></span><br><span class="line">    compile &quot;com.facebook.react:react-native:+&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里可以看到，我们工程的编译版本已经修改为23，引用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:appcompat-v7:23.0.1</span><br></pre></td></tr></table></figure><h3 id="7-修改maven为本地路径"><a href="#7-修改maven为本地路径" class="headerlink" title="7. 修改maven为本地路径"></a>7. 修改maven为本地路径</h3><p>在工程根目录下，找到build.gradle文件，添加maven路径为本地生成的node-modules</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">maven &#123;</span><br><span class="line">    // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm</span><br><span class="line">    url &quot;$rootDir/../node_modules/react-native/android&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完成后，完整的文件为：</p><p><img src="http://image.jucaiwy.com/image/20180104/RGxteet.png"></p><h3 id="8-添加Application"><a href="#8-添加Application" class="headerlink" title="8. 添加Application"></a>8. 添加Application</h3><p>为当前工程指定Application，新建一个Application，继承自ReactApplication，这里需要注意的是，如果当前编译版本不是23，那么在新建这个类的时候，将会提示<strong>找不到ReactApplication</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> <span class="keyword">extends</span> <span class="title class_">Application</span> <span class="keyword">implements</span> <span class="title class_">ReactApplication</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReactNativeHost</span> <span class="variable">mReactNativeHost</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReactNativeHost</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getUseDeveloperSupport</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> BuildConfig.DEBUG;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> List&lt;ReactPackage&gt; <span class="title function_">getPackages</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.&lt;ReactPackage&gt;asList(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">MainReactPackage</span>()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReactNativeHost <span class="title function_">getReactNativeHost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mReactNativeHost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建完成后：</p><ol><li>需要再AndroidManifest.xml中为当前项目添加这个application的注册</li><li>需要添加网络权限，因为需要从服务端刷新js界面<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li>需要添加调试界面DevSettingsActivity <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=&quot;com.facebook.react.devsupport.DevSettingsActivity&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="9-修改MainActivity"><a href="#9-修改MainActivity" class="headerlink" title="9. 修改MainActivity"></a>9. 修改MainActivity</h3><p>首先在MainActivity的布局文件中添加ReactRootView，我这里直接删除了之前新建工程默认出现的TextView，替换为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">com.facebook.react.ReactRootView</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:id</span>=<span class="string">&quot;@+id/react_root_view_id&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:layout_width</span>=<span class="string">&quot;300dp&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:layout_height</span>=<span class="string">&quot;300dp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后修改MainActivity：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">    ReactRootView reactRootView;</span><br><span class="line">    ReactInstanceManager reactInstanceManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.react_root_view);</span><br><span class="line">        reactRootView = (ReactRootView) findViewById(R.id.react_root_view_id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里需要注意，官方文档setJSMainModuleName在0.51.0版本中找不到，替换为setJSMainModulePath</span></span><br><span class="line">        reactInstanceManager = ReactInstanceManager.builder()</span><br><span class="line">                .setApplication(getApplication())</span><br><span class="line">                .setBundleAssetName(<span class="string">&quot;index.android.bundle&quot;</span>)</span><br><span class="line">                .setJSMainModulePath(<span class="string">&quot;index.android&quot;</span>)</span><br><span class="line">                .addPackage(<span class="keyword">new</span> <span class="title class_">MainReactPackage</span>())</span><br><span class="line">                .setUseDeveloperSupport(BuildConfig.DEBUG)</span><br><span class="line">                .setInitialLifecycleState(LifecycleState.RESUMED)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ReactNative 是项目名，需要和index.adnroid.js中的保持一致</span></span><br><span class="line">        reactRootView.startReactApplication(reactInstanceManager, <span class="string">&quot;ReactNative&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，已经完成了配置，我们可以运行当前应用到真机上，然后启动npm进行测试了</p><h3 id="10-测试"><a href="#10-测试" class="headerlink" title="10. 测试"></a>10. 测试</h3><pre><code>1. 启动npm，在Terminal窗口中，输入 npm start即可启动2. 运行当前App到手机上3. 手机必须和电脑在同意网段，可以使用电脑开个热点，手机连接4. 手机进入应用后，摇一摇，会出现debug的dialog，可以配置IP和端口</code></pre><h3 id="11-后记："><a href="#11-后记：" class="headerlink" title="11. 后记："></a>11. 后记：</h3><p>这个文章是我一遍搭建，一边整理的，参考了<a href="http://blog.csdn.net/github_33304260/article/details/76571961">http://blog.csdn.net/github_33304260&#x2F;article&#x2F;details&#x2F;76571961</a> 可能存在配置问题，有缘人看到了，可以试试，有啥问题，随时留言或者和我联系，我再进行更新文档</p>]]></content>
    
    
    <summary type="html">AndroidStudio集成ReactNative到已有工程</summary>
    
    
    
    <category term="ReactNative" scheme="http://example.com/categories/ReactNative/"/>
    
    
    <category term="ReactNative" scheme="http://example.com/tags/ReactNative/"/>
    
    <category term="集成RN" scheme="http://example.com/tags/%E9%9B%86%E6%88%90RN/"/>
    
  </entry>
  
  <entry>
    <title>IJKPlayer使用SeekTo跳转关键帧不正确</title>
    <link href="http://example.com/2017/12/21/20171221IJKPlayer%E4%BD%BF%E7%94%A8SeekTo%E8%B7%B3%E8%BD%AC%E5%85%B3%E9%94%AE%E5%B8%A7%E4%B8%8D%E6%AD%A3%E7%A1%AE/"/>
    <id>http://example.com/2017/12/21/20171221IJKPlayer%E4%BD%BF%E7%94%A8SeekTo%E8%B7%B3%E8%BD%AC%E5%85%B3%E9%94%AE%E5%B8%A7%E4%B8%8D%E6%AD%A3%E7%A1%AE/</id>
    <published>2017-12-21T09:56:53.000Z</published>
    <updated>2020-12-09T06:35:50.450Z</updated>
    
    <content type="html"><![CDATA[<p>今天在做一个视频播放的功能，播放内核使用的IJKPlayer，在拖动进度条进行跳转的时候，发现跳转位置总是不准确，尤其在10秒以内的视频播放中进行拖动，跳转的更不准确，经常调至开头或者结尾。</p><p>分析其原因，发现进度条SeekBar定位是没有问题的，但是使用IjkMediaPlayer.seekTo(int position)方法时，总是不能准确定位。分析是IjkMediaPlayer内部问题，可能因为视频时间较短，压缩率较高等原因，导致关键帧确实，进度条定点位置内没有找到关键帧，所以，定位不准确。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>在初始化视频播放器的时候，添加seekTo支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((IjkMediaPlayer)mMediaPlayer).setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, <span class="string">&quot;enable-accurate-seek&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>至于这个配置具体还有别的什么，我再找找。</p>]]></content>
    
    
    <summary type="html">IJKPlayer使用SeekTo跳转关键帧不正确</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    <category term="问题记录" scheme="http://example.com/categories/Android/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
    <category term="IJKPlayer" scheme="http://example.com/tags/IJKPlayer/"/>
    
  </entry>
  
  <entry>
    <title>HEIF图片存储格式探秘</title>
    <link href="http://example.com/2017/12/11/20171211HEIF%E5%9B%BE%E7%89%87%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F%E6%8E%A2%E7%A7%98/"/>
    <id>http://example.com/2017/12/11/20171211HEIF%E5%9B%BE%E7%89%87%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F%E6%8E%A2%E7%A7%98/</id>
    <published>2017-12-11T10:30:43.000Z</published>
    <updated>2022-04-19T07:08:57.360Z</updated>
    
    <content type="html"><![CDATA[<p>HEIF，High Efficiency Image File Format，即高效率图档格式，是由动态图像专家组（MPEG–Moving Picture Experts Group ）在2013年推出的存储图片和图片序列的新格式，用于HEVC关键帧的处理上，因此它同样可以用更少的容量来存储画质更好的照片，在连拍、动图和色彩变化不大的照片上效果尤其明显。</p><p>官网：<a href="http://nokiatech.github.io/heif/">http://nokiatech.github.io/heif/</a></p><p>比较：<a href="http://nokiatech.github.io/heif/comparison.html">http://nokiatech.github.io/heif/comparison.html</a></p><p>GitHub地址：<a href="https://github.com/nokiatech/heif">https://github.com/nokiatech/heif</a></p><p>在git的wiki上有说明如何进行编译，需要再linux中进行编译，今天安装了linux系统，然后，准备编译一下。</p><h3 id="1-编译构建"><a href="#1-编译构建" class="headerlink" title="1. 编译构建"></a>1. 编译构建</h3><p>从GitHub上下载了Nokia的代码，语言不通，几乎看不懂，但是，从wiki上看到了如何进行编译和构建，于是决定试试。</p><p>在Linux环境下，打开命令行模式，输入命令进行下载：</p><p><img src="http://image.jucaiwy.com/image/20161211/I9eaox5.png"></p><p>下载完成后，可以看到目录结构如下：</p><p><img src="http://image.jucaiwy.com/image/20161211/HH0eXqI.png"></p><p>然后，进入heif目录，新建文件夹，命名为build，然后进入build，执行cmake .. </p><p><img src="http://image.jucaiwy.com/image/20161211/IpuSeOp.png"></p><p>然后执行make：</p><p><img src="http://image.jucaiwy.com/image/20161211/4R9eq3Y.png"></p><p>生成了可执行的writerapp的执行文件，但是现在还不知道怎么执行。</p><h3 id="2-转换工具："><a href="#2-转换工具：" class="headerlink" title="2. 转换工具："></a>2. 转换工具：</h3><p><a href="https://liuziangexit.com/HEIF-Utility/">HEIF Utility</a></p><p>这个转换工具，今天测试了以下，不是很好用。</p><h3 id="3-Android项目Demo"><a href="#3-Android项目Demo" class="headerlink" title="3. Android项目Demo"></a>3. Android项目Demo</h3><p><a href="https://github.com/yohhoy/heifreader">https://github.com/yohhoy/heifreader</a></p><p>这个项目使用了 <a href="https://github.com/sannies/mp4parser">sannies&#x2F;mp4parser </a>这个库解析HEIF结构。目前为止存在bug，没有解决，可能是因为当前技术不完善吧</p><h3 id="4-各种不支持"><a href="#4-各种不支持" class="headerlink" title="4. 各种不支持"></a>4. 各种不支持</h3><p>Windows不支持，PhotoShopCC不支持，低版本的iPhone、Mac均不支持该格式，微信，微博等均不支持（测试了Android版本的）</p><h3 id="5-在线的HEIF图片地址："><a href="#5-在线的HEIF图片地址：" class="headerlink" title="5. 在线的HEIF图片地址："></a>5. 在线的HEIF图片地址：</h3><p>这里找到了一些在线的图片地址，heic格式的，是诺基亚官方提供的，以后研究的时候可以使用</p><p>在线地址：<a href="https://github.com/nokiatech/heif/tree/gh-pages/content/images">https://github.com/nokiatech/heif/tree/gh-pages/content/images</a></p><h3 id="6-没有快速推广的原因："><a href="#6-没有快速推广的原因：" class="headerlink" title="6. 没有快速推广的原因："></a>6. 没有快速推广的原因：</h3><ol><li>专利费，齁贵，各大厂硬件厂商用不起</li><li>格式暂时未通用，各大软件服务商，暂时没有支持，表现在Windows也无法产生这种文档的图示，而且Photoshop也不支持该格式的图片编辑，目前仅苹果支持。</li></ol>]]></content>
    
    
    <summary type="html">HEIF图片存储格式探秘</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    <category term="HEIF" scheme="http://example.com/categories/Android/HEIF/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
    <category term="IJKPlayer" scheme="http://example.com/tags/IJKPlayer/"/>
    
    <category term="IOS11图片格式" scheme="http://example.com/tags/IOS11%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/"/>
    
    <category term="图片存储" scheme="http://example.com/tags/%E5%9B%BE%E7%89%87%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>斗地主算法</title>
    <link href="http://example.com/2017/07/10/20170710TienLen%E6%B8%B8%E6%88%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%96%97%E5%9C%B0%E4%B8%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2017/07/10/20170710TienLen%E6%B8%B8%E6%88%8F%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%96%97%E5%9C%B0%E4%B8%BB%E7%AE%97%E6%B3%95/</id>
    <published>2017-07-10T10:34:46.000Z</published>
    <updated>2020-12-09T06:34:56.010Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要做一个类似于斗地主的游戏，由于只是类似斗地主的游戏，因此，规则方面和斗地主存在一些不同，但是在算法上，也是大同小异，现对该游戏算法进行总结：</p><h3 id="1-定义牌对象"><a href="#1-定义牌对象" class="headerlink" title="1.定义牌对象"></a>1.定义牌对象</h3><p> 首先需要对牌对象进行定义，正常斗地主玩法下，一张牌只有一个属性，就是数字大小，而不管花色，而在我们的游戏中，同样数字的牌，不同花色之间还可以比较，因此，我们的牌一共有两个基本属性，分别为花色和大小。</p><h4 id="1-1-规则"><a href="#1-1-规则" class="headerlink" title="1.1 规则"></a>1.1 规则</h4><p>对于花色，规则定义如下：黑桃&gt;梅花&gt;方片&gt;红桃</p><p>对于数字，规则定义如下：2最大，3最小</p><h4 id="1-2-建模"><a href="#1-2-建模" class="headerlink" title="1.2 建模"></a>1.2 建模</h4><p>我们将牌的牌面实际数字使用数字进行标记，使用数字3到15表示真实牌的3到2，其中11表示J，12表示Q，13表示K，14表示A，15表示2，其余数字分别代表真实牌面数字。</p><p>将牌的牌面花色同样使用数字进行标记：根据从大到小，分别标记为：4——黑桃，3——梅花，2——方片，1——红桃。</p><p>这样，对于一张牌的数字模型，使用以下公式进行标记：</p><p>牌数字模型大小  &#x3D;  牌面数字模型大小 * 10 + 牌面花色模型大小</p><pre><code>// 牌号点数：如3~J~A~2,使用3~15数字private int cardNumber;    // 牌色：如4红桃, 3方片, 2梅花, 1黑桃private int cardColor;    // 牌全称：例34是红桃3,152是梅花2,113是方片Jprivate String cardName;    // 牌描述：例红桃3,梅花2private String cardDesc;</code></pre><h4 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h4><p>经过上边的标记，我们很容易将一张牌的模型进行数字化，例如：</p><p>154——黑桃2</p><p>151——红桃2</p><p>83——梅花8</p><p>这样154&gt;151，同样黑桃2大于红桃2</p><p>151&gt;83，同样红桃2大于梅花8</p><h3 id="2-构建一副牌"><a href="#2-构建一副牌" class="headerlink" title="2. 构建一副牌"></a>2. 构建一副牌</h3><p>构建一副牌可以从花色、牌面大小、牌的名称、牌的描述四个方面进行构建，其中花色（4——黑桃，3——梅花，2——方片，1——红桃），大小为：使用数字3到15表示真实牌的3到2，牌名称即牌大小和花色组成的数字大小，描述是通用的牌的叫法，比如：154——黑桃2 牌名称为154 描述为 黑桃2</p><p>这里需要主要的是：<strong>斗地主中存在王，大小王，共54张牌，而在我们的TienLen游戏中不存在大小王，只有52张牌</strong></p><pre><code>/** * 初始化牌 * @return */public List&lt;CardInfo&gt; initCard() &#123;    List&lt;CardInfo&gt; cardList = new ArrayList&lt;CardInfo&gt;();    for (int i = 1; i &lt; 5; i++) &#123;        for (int j = 3; j &lt; 16; j++) &#123;            CardInfo cardInfo = new CardInfo();            cardInfo.setCardNumber(j);            cardInfo.setCardColor(i);            cardInfo.setCardName(j * 10 + i + &quot;&quot;);            switch (i) &#123;                case 1:                    cardInfo.setCardDesc(&quot;红桃&quot; + j);                    break;                case 2:                    cardInfo.setCardDesc(&quot;方片&quot; + j);                    break;                case 3:                    cardInfo.setCardDesc(&quot;梅花&quot; + j);                    break;                case 4:                    cardInfo.setCardDesc(&quot;黑桃&quot; + j);                    break;            &#125;            cardList.add(cardInfo);        &#125;    &#125;    return cardList;&#125;</code></pre><h3 id="3-洗牌"><a href="#3-洗牌" class="headerlink" title="3. 洗牌"></a>3. 洗牌</h3><p>洗牌只需要将牌进行打乱即可，这里考虑使用随机数进行交换，模拟洗牌，但是这样的算法存在缺陷，即有可能洗完以后，牌仍然保持原样</p><pre><code>/** * 洗牌 * * @param cardList 初始化号的牌 * @return */public List&lt;CardInfo&gt; washCard(List&lt;CardInfo&gt; cardList) &#123;    List&lt;CardInfo&gt; randomCardList = cardList;    for (int i = 0; i &lt; 100; i++) &#123;        Random random = new Random();        // 找出52以内的随机数，然后交换位置        int a = random.nextInt(52);        int b = random.nextInt(52);        CardInfo cardInfoTemp = randomCardList.get(a);        randomCardList.set(a, randomCardList.get(b));        randomCardList.set(b, cardInfoTemp);    &#125;    return randomCardList;&#125;</code></pre><h3 id="4-发牌"><a href="#4-发牌" class="headerlink" title="4. 发牌"></a>4. 发牌</h3><p>发牌算法很简单，将已经洗好的52张牌，顺序发给各个玩家。这里我们与斗地主区别在于，我们这里一共有四个玩家，因此需要将牌分为4份：</p><pre><code>/** * 发牌 * * @param cardList 洗好的牌 * @return */public List&lt;CardInfo&gt;[] handCard(List&lt;CardInfo&gt; cardList) &#123;    List&lt;CardInfo&gt; playerCardList[] = new Vector[4];    for (int i = 0; i &lt; 4; i++) &#123;        playerCardList[i] = new Vector&lt;CardInfo&gt;();    &#125;    for (int j = 0; j &lt; 52; j++) &#123;        switch (j % 4) &#123;            case 0:                playerCardList[0].add(cardList.get(j));                break;            case 1:                playerCardList[1].add(cardList.get(j));                break;            case 2:                playerCardList[2].add(cardList.get(j));                break;            case 3:                playerCardList[3].add(cardList.get(j));                break;            default:                break;        &#125;    &#125;    return playerCardList;&#125;</code></pre><h3 id="5-捋牌"><a href="#5-捋牌" class="headerlink" title="5. 捋牌"></a>5. 捋牌</h3><p>也就是对牌进行排序，从大到小进行排序，这样出来的牌，便于往后进行分类等运算。</p><pre><code>/** * 排序，按照从大到小的顺序进行排 * * @param cardList * @return */public List&lt;CardInfo&gt; sortCard(List&lt;CardInfo&gt; cardList) &#123;    Collections.sort(cardList, new Comparator&lt;CardInfo&gt;() &#123;        @Override        public int compare(CardInfo cardInfo1, CardInfo cardInfo2) &#123;            int cardNum1 = Integer.valueOf(cardInfo1.getCardName());            int cardNum2 = Integer.valueOf(cardInfo2.getCardName());            if (cardNum1 &gt; cardNum2) &#123;                return -1;            &#125; else if (cardNum1 == cardNum2) &#123;                return 0;            &#125; else &#123;                return 1;            &#125;        &#125;    &#125;);    return cardList;&#125;</code></pre><h3 id="6-出牌"><a href="#6-出牌" class="headerlink" title="6. 出牌"></a>6. 出牌</h3><p>   出牌时，应该根据规则进行出牌，首先、判断用户所选择的牌是否符合规则，即是否是单牌、对子、三张、链子、炸弹等</p><h4 id="6-1-单张牌"><a href="#6-1-单张牌" class="headerlink" title="6.1 单张牌"></a>6.1 单张牌</h4><p>获取单张牌的算法很简单，任意一张牌，都可以作为单张牌使用，因此只需要将所有的牌都添加到单张牌的列表中即可。</p><pre><code> /*** * 获取单张牌 * * @param mCardList * @return */public List&lt;List&lt;CardInfo&gt;&gt; get1(List&lt;CardInfo&gt; mCardList) &#123;    List&lt;List&lt;CardInfo&gt;&gt; all1List = new ArrayList&lt;&gt;();    List&lt;CardInfo&gt; cardList;    sortCardAsc(mCardList);    for (int i = 0, length = mCardList.size(); i &lt; length; i++) &#123;        cardList = new ArrayList&lt;&gt;();        cardList.add(mCardList.get(i));        all1List.add(cardList);    &#125;    return all1List;&#125;</code></pre><h4 id="6-2-对子"><a href="#6-2-对子" class="headerlink" title="6.2 对子"></a>6.2 对子</h4><p>获取对子时，需要注意，因为我们TienLen游戏的规则中，不仅需要比较牌面点数大小，还需要比较花色大小，所以，同样4个2，可能组合成多种对子，且大小不一样，比如黑桃2和梅花2，比如红桃2和方片2</p><pre><code> /** * 获取对子 * 这里对i+1 i+2 i+3分别和第i张牌进行对比， * 举例：比如四个2，可以黑桃2和方片2一对，也可以是梅花2和红桃2一对 * * @param mCardList * @return */public List&lt;List&lt;CardInfo&gt;&gt; get11(List&lt;CardInfo&gt; mCardList) &#123;    // 先对牌进行排序    sortCardAsc(mCardList);    List&lt;List&lt;CardInfo&gt;&gt; all11CardList = new ArrayList&lt;&gt;();    List&lt;CardInfo&gt; cardList;    for (int i = 0, length = mCardList.size(); i &lt; length; i++) &#123;        if (i + 1 &lt; length                &amp;&amp; mCardList.get(i).getCardNumber() == mCardList.get(i + 1).getCardNumber()) &#123;            cardList = new ArrayList&lt;&gt;();            cardList.add(mCardList.get(i));            cardList.add(mCardList.get(i + 1));            all11CardList.add(cardList);        &#125;        if (i + 2 &lt; length                &amp;&amp; mCardList.get(i).getCardNumber() == mCardList.get(i + 2).getCardNumber()) &#123;            cardList = new ArrayList&lt;&gt;();            cardList.add(mCardList.get(i));            cardList.add(mCardList.get(i + 2));            all11CardList.add(cardList);        &#125;        if (i + 3 &lt; length                &amp;&amp; mCardList.get(i).getCardNumber() == mCardList.get(i + 3).getCardNumber()) &#123;            cardList = new ArrayList&lt;&gt;();            cardList.add(mCardList.get(i));            cardList.add(mCardList.get(i + 3));            all11CardList.add(cardList);        &#125;    &#125;    return all11CardList;&#125;</code></pre><h3 id="6-3-三个"><a href="#6-3-三个" class="headerlink" title="6.3 三个"></a>6.3 三个</h3><p>在斗地主的规则中，好像也是三个也可以一起出，但是需要带一个或者一对，我们TienLen游戏中不需要带，也不能带，可以直接出，比如三个三，三个四，这样的牌，获取的算法和上边对子的获取算法一致</p><pre><code> /*** * 获取三个 * 算法个获取对子的算法类似 * * @param mCardList * @return */public List&lt;List&lt;CardInfo&gt;&gt; get111(List&lt;CardInfo&gt; mCardList) &#123;    List&lt;List&lt;CardInfo&gt;&gt; all111List = new ArrayList&lt;&gt;();    List&lt;CardInfo&gt; cardList;    // 先对牌进行排序    sortCardAsc(mCardList);    for (int i = 0, length = mCardList.size(); i &lt; length; i++) &#123;        if (i + 2 &lt; length                &amp;&amp; mCardList.get(i).getCardNumber() == mCardList.get(i + 2).getCardNumber()) &#123;            cardList = new ArrayList&lt;&gt;();            cardList.add(mCardList.get(i));            cardList.add(mCardList.get(i + 1));            cardList.add(mCardList.get(i + 2));            all111List.add(cardList);        &#125;    &#125;    return all111List;&#125;</code></pre><h3 id="6-4-炸弹"><a href="#6-4-炸弹" class="headerlink" title="6.4 炸弹"></a>6.4 炸弹</h3><p>炸弹，不论在斗地主中还是我们现在做的TienLen中，都是一样的作用，一样的获取方法，和获取对子，三个的方法一致，这里直接上代码：</p><pre><code>/*** * 获取炸弹 * * @param mCardList * @return */public List&lt;List&lt;CardInfo&gt;&gt; get1111(List&lt;CardInfo&gt; mCardList) &#123;    List&lt;List&lt;CardInfo&gt;&gt; all1111List = new ArrayList&lt;&gt;();    List&lt;CardInfo&gt; cardList;    for (int i = 0, length = mCardList.size(); i &lt; length; i++) &#123;        if (i + 3 &lt; length                &amp;&amp; mCardList.get(i).getCardNumber() == mCardList.get(i + 3).getCardNumber()) &#123;            cardList = new ArrayList&lt;&gt;();            cardList.add(mCardList.get(i));            cardList.add(mCardList.get(i + 1));            cardList.add(mCardList.get(i + 2));            cardList.add(mCardList.get(i + 3));            all1111List.add(cardList);        &#125;    &#125;    return all1111List;&#125;</code></pre><h3 id="6-5-链子"><a href="#6-5-链子" class="headerlink" title="6.5 链子"></a>6.5 链子</h3><p>终于说到了这个牌型——链子，链子在不同的玩法中，可以出不同的长度，在我们的TienLen中最少是三联，这里获取时，先对手牌进行排序，排好序后，进行遍历，找到能和当前牌连接起来的，且牌长度大于3的，均属于链子：</p><pre><code>/** * 获取链子 * * @param mCardList * @return */public List&lt;List&lt;CardInfo&gt;&gt; get123(List&lt;CardInfo&gt; mCardList) &#123;    // 链子长度必须大于3,即最少出3连    if (mCardList.size() &lt; 3) &#123;        return null;    &#125;    // 构建返回数据    List&lt;CardInfo&gt; tempCardList = new ArrayList&lt;&gt;();    List&lt;List&lt;CardInfo&gt;&gt; all123List = new ArrayList&lt;&gt;();    // 先去掉2    for (int i = 0; i &lt; mCardList.size(); i++) &#123;        if (mCardList.get(i).getCardNumber() != 15) &#123;            tempCardList.add(mCardList.get(i));        &#125;    &#125;    // 重新进行排序    sortCardAsc(tempCardList);    for (int i = 0; i &lt; tempCardList.size(); i++) &#123;        CardInfo tempCardInfo = tempCardList.get(i);        List&lt;CardInfo&gt; cardList = new ArrayList&lt;&gt;();        cardList.add(tempCardInfo);        List&lt;CardInfo&gt; cardListTempAfter = new ArrayList&lt;&gt;();        for (int j = i + 1; j &lt; tempCardList.size(); j++) &#123;            // 判断当前牌是否个下一个牌能连起来（当前牌是5，当下一个是5+1=6时，即连起来了，当连起来大于3个牌时，即可以认为是一连）            if ((tempCardInfo.getCardNumber() + 1) == tempCardList.get(j).getCardNumber()) &#123;                cardListTempAfter.clear();                cardListTempAfter.addAll(cardList);                cardList.add(tempCardList.get(j));                tempCardInfo = tempCardList.get(j);                if (cardList.size() &gt;= 3) &#123;                    List&lt;CardInfo&gt; cardListTemp = new ArrayList&lt;&gt;();                    cardListTemp.addAll(cardList);                    all123List.add(cardList);                    cardList = new ArrayList&lt;&gt;();                    cardList.addAll(cardListTemp);                &#125;            &#125; else if (tempCardInfo.getCardNumber() == tempCardList.get(j).getCardNumber()                    &amp;&amp; tempCardInfo.getCardNumber() != tempCardList.get(i).getCardNumber()) &#123;                List&lt;CardInfo&gt; cardListTemp = new ArrayList&lt;&gt;();                cardListTemp.addAll(cardListTempAfter);                if (cardListTemp.size() &gt; 0                        &amp;&amp; cardListTemp.get(cardListTemp.size() - 1).getCardNumber() != tempCardList                        .get(j).getCardNumber()) &#123;                    cardListTempAfter.add(tempCardList.get(j));                    if (cardListTempAfter.size() &gt;= 3) &#123;                        all123List.add(cardListTempAfter);                        cardListTempAfter = new ArrayList&lt;&gt;();                        cardListTempAfter.addAll(cardListTemp);                    &#125;                &#125;            &#125;        &#125;    &#125;    return all123List;&#125;</code></pre><h3 id="6-6-双链"><a href="#6-6-双链" class="headerlink" title="6.6 双链"></a>6.6 双链</h3><p>双链，也就是经常说的飞机带翅膀，双链的前提是对子，只有存在对子的情况下，才能找出来双链，所以，其算法也是一样，先找到所有的对子，然后去掉2，进行排序，再按照找链子的方法进行找，这样返回的就是双链。</p><pre><code> /*** * 获取飞机 * * @param mCardInfoList * @return */public List&lt;List&lt;CardInfo&gt;&gt; get112233(List&lt;CardInfo&gt; mCardInfoList) &#123;    int length = mCardInfoList.size();    // 双链最少为3连，所以最少六张牌    if (length &lt; 6) &#123;        return null;    &#125;    // 保存所有的对子    List&lt;CardInfo&gt; tempList = new ArrayList&lt;&gt;();    // 保存所有不包含2的对子    List&lt;CardInfo&gt; apairTempList = new ArrayList&lt;&gt;();    // 防止重复添加    List&lt;Integer&gt; integerList = new Vector&lt;&gt;();    // 返回结果    List&lt;List&lt;CardInfo&gt;&gt; all112233List = new ArrayList&lt;&gt;();    // 存储单个双对链子    List&lt;CardInfo&gt; cardList;    // 先获取所有的对子    for (int i = 0; i &lt; length; i++) &#123;        if (i + 1 &lt; length                &amp;&amp; mCardInfoList.get(i).getCardNumber() == mCardInfoList.get(i + 1)                .getCardNumber()) &#123;            tempList.add(mCardInfoList.get(i));            tempList.add(mCardInfoList.get(i + 1));            i = i + 1;        &#125;    &#125;    // 排序    sortCardAsc(tempList);    // 去除对2和相同的    for (int i = 0, tempLength = tempList.size(); i &lt; tempLength; i++) &#123;        if (!integerList.contains(Integer.valueOf(tempList.get(i).getCardNumber()))) &#123;            apairTempList.add(tempList.get(i));            integerList.add(Integer.valueOf(tempList.get(i).getCardNumber()));        &#125;    &#125;    // 双对的链子最少三联    if (apairTempList.size() &lt; 3) &#123;        return null;    &#125;    // 对之前拿到的对子List进行排序，正序    sortCardAsc(tempList);    // 到这里已经拿到了所有对子中的某一个单牌，只需拿出所有的链子    List&lt;List&lt;CardInfo&gt;&gt; get123TempList = get123(apairTempList);    for (int j = 0; j &lt; get123TempList.size(); j++) &#123;        List&lt;CardInfo&gt; list123 = get123TempList.get(j);        sortCardAsc(list123);        for (int k = 0; k &lt; tempList.size(); k++) &#123;            if (tempList.get(k).getCardName().equals(list123.get(0).getCardName())) &#123;                cardList = new ArrayList&lt;&gt;();                for (int l = k; l &lt; list123.size() * 2 + k; l++) &#123;                    cardList.add(tempList.get(l));                &#125;                all112233List.add(cardList);            &#125;        &#125;    &#125;    return all112233List;&#125;</code></pre><h3 id="7-出牌"><a href="#7-出牌" class="headerlink" title="7 出牌"></a>7 出牌</h3><p>出牌有两种情况，一种是手动选择的，一种是通过提示，自动出牌的。对于手动选择的，需要根据自己当前是否有首先出牌权，进行校验，</p><ol><li>如果当前是自己的局，也就是说，上轮出牌的过程中，自己最大，这局自己首先出，所以只需要校验自己手动选择的牌是否符合规则。</li><li>如果当前是别人的局，也就是说，自己当前跟着别人的局出牌，只能和别人的类型一致，且大于对方，所以需要校验选择的牌类型是否和别人的一致，再校验是否比别人的大，才能出</li></ol><p>对于通过提示出牌的，只适合第二种情况，也就是说，别人出牌，然后自己管，系统会进行提示</p><h4 id="7-1-判断所选择的牌，是否符合已经定义的出牌类型，对应上边所述的第一种情况，只要符合规则均可以出"><a href="#7-1-判断所选择的牌，是否符合已经定义的出牌类型，对应上边所述的第一种情况，只要符合规则均可以出" class="headerlink" title="7.1 判断所选择的牌，是否符合已经定义的出牌类型，对应上边所述的第一种情况，只要符合规则均可以出"></a>7.1 判断所选择的牌，是否符合已经定义的出牌类型，对应上边所述的第一种情况，只要符合规则均可以出</h4><pre><code> /** * 获取出牌类型 *  * @param outCard * @return */public OutCardType getOutCardType(List&lt;CardInfo&gt; outCard) &#123;    if (outCard != null) &#123;        int cardLength = outCard.size();        if (outCard.get(0).getCardNumber() == outCard.get(cardLength - 1).getCardNumber()) &#123;            switch (cardLength) &#123;                case 1:                    // 单牌                    return OutCardType.type1;                case 2:                    // 对子                    return OutCardType.type11;                case 3:                    // 三个                    return OutCardType.type111;                case 4:                    // 炸弹                    return OutCardType.type1111;            &#125;        &#125;        // 判断链子，最少三张        if (outCard.size() &gt;= 3) &#123;            List&lt;CardInfo&gt; tempCardList = new ArrayList&lt;&gt;();            // 先去掉2            for (int i = 0; i &lt; outCard.size(); i++) &#123;                if (outCard.get(i).getCardNumber() != 15) &#123;                    tempCardList.add(outCard.get(i));                &#125;            &#125;            // 重新进行排序            sortCardAsc(tempCardList);            // 判断是否为链子            List&lt;List&lt;CardInfo&gt;&gt; get123 = get123(outCard);            if (get123 != null &amp;&amp; get123.size() &gt; 0) &#123;                for (List&lt;CardInfo&gt; list : get123) &#123;                    if (list.size() == outCard.size()) &#123;                        return OutCardType.type123;                    &#125;                &#125;            &#125;            // 双对至少6张            if (outCard.size() &gt;= 6) &#123;                int length = outCard.size();                // 保存所有的对子                List&lt;CardInfo&gt; tempList = new ArrayList&lt;&gt;();                // 保存所有不包含2的对子                List&lt;CardInfo&gt; apairTempList = new ArrayList&lt;&gt;();                // 防止重复添加                List&lt;Integer&gt; integerList = new Vector&lt;&gt;();                // 先获取所有的对子                for (int i = 0; i &lt; length; i++) &#123;                    if (i + 1 &lt; length                            &amp;&amp; outCard.get(i).getCardNumber() == outCard.get(i + 1)                            .getCardNumber()) &#123;                        tempList.add(outCard.get(i));                        tempList.add(outCard.get(i + 1));                        i = i + 1;                    &#125;                &#125;                // 所有的牌均为对子                if (tempList.size() == outCard.size()) &#123;                    // 去除对2                    for (int i = 0, tempLength = tempList.size(); i &lt; tempLength; i++) &#123;                        if (integerList.indexOf(outCard.get(i).getCardNumber()) &lt; 0                                &amp;&amp; tempList.get(i).getCardNumber() != 15) &#123;                            apairTempList.add(tempList.get(i));                            integerList.add(tempList.get(i).getCardNumber());                        &#125;                        i = i + 1;                    &#125;                    // 到这里已经拿到了所有对子中的某一个单牌，只需拿出所有的链子                    List&lt;List&lt;CardInfo&gt;&gt; get123TempList = get123(apairTempList);                    for (int i = 0; i &lt; get123TempList.size(); i++) &#123;                        if (get123TempList.get(i).size() == length / 2) &#123;                            return OutCardType.type112233;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    return OutCardType.type0;&#125;</code></pre><p>只有当选中牌的类型是已知类型，才能第一步判断出是否可以出牌，下一步则需要根据当前是不是自己轮，判断需要不需要压对方的牌</p><h4 id="7-2-判断当前所选择的牌，是否符合规则，而且，是否比上一家出的牌大"><a href="#7-2-判断当前所选择的牌，是否符合规则，而且，是否比上一家出的牌大" class="headerlink" title="7.2 判断当前所选择的牌，是否符合规则，而且，是否比上一家出的牌大"></a>7.2 判断当前所选择的牌，是否符合规则，而且，是否比上一家出的牌大</h4><pre><code>/** * 当上家出牌后，判断自己是否可以出牌 * * @param outCard * @param mAllCard * @param mSelectCard * @return */public boolean whetherCanPlay(List&lt;CardInfo&gt; outCard, List&lt;CardInfo&gt; mAllCard,                              List&lt;CardInfo&gt; mSelectCard) &#123;    boolean isCardCanPlay = false;    // 获取对手牌型    OutCardType outCardType = getOutCardType(outCard);    OutCardType outCardTypeMy = getOutCardType(mSelectCard);    sortCard(outCard);    // 先对牌进行排序    sortCard(mSelectCard);    // 首先判断牌的张数是否一样    if (outCard.size() == mSelectCard.size() &amp;&amp; outCardType == outCardTypeMy) &#123;        int outCardName = Integer.valueOf(outCard.get(0).getCardName());        int mSelectCardName = Integer.valueOf(mSelectCard.get(0).getCardName());        // 相同，属于同一级牌之间压        switch (outCardType) &#123;            case type1:                if (mSelectCardName &gt; outCardName) &#123;                    isCardCanPlay = true;                &#125;                break;            case type11:                if (mSelectCardName &gt; outCardName) &#123;                    isCardCanPlay = true;                &#125;                break;            case type111:                if (mSelectCardName &gt; outCardName) &#123;                    isCardCanPlay = true;                &#125;                break;            case type1111:                if (mSelectCardName &gt; outCardName) &#123;                    isCardCanPlay = true;                &#125;                break;            case type123:                if (mSelectCardName &gt; outCardName) &#123;                    isCardCanPlay = true;                &#125;                break;            case type112233:                if (mSelectCardName &gt; outCardName) &#123;                    isCardCanPlay = true;                &#125;                break;            default:                isCardCanPlay = false;                break;        &#125;    &#125; else &#123;        // 当张数不一致时，有两种情况，即炸弹压2和连着的双对压对2        if (outCard.size() == 1 &amp;&amp; mSelectCard.size() == 4) &#123;            // 当别人为单个2且自己的Type为炸弹时            if (outCard.get(0).getCardNumber() == 15                    &amp;&amp; getOutCardType(mSelectCard) == OutCardType.type1111) &#123;                isCardCanPlay = true;            &#125;        &#125; else &#123;            // 别人出牌为一对2，自己应该用33-44-55-66或者55-66-77-88压            if (outCard.size() == 2 &amp;&amp; mSelectCard.size() &gt;= 8) &#123;                if (outCard.get(0).getCardNumber() == 15                        &amp;&amp; getOutCardType(mSelectCard) == OutCardType.type112233) &#123;                    isCardCanPlay = true;                &#125;            &#125; else &#123;                isCardCanPlay = false;            &#125;        &#125;    &#125;    return isCardCanPlay;&#125;</code></pre><p>这里边包含了部分规则，比如同样的牌类型，比较大小，同时33445566可以压对二这样的规则</p><h3 id="8-提示"><a href="#8-提示" class="headerlink" title="8. 提示"></a>8. 提示</h3><p> 提示算法比较简单，先获取上家出牌的类型，再获取自己手牌中对应类型的列表，逐个进行比较，直到找到合适的</p><h3 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h3><p>这里除了上述洗牌、发牌、出牌等算法之外，还有单机模式的AI算法，回头有空了整理下，我再发上来吧。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这片文章中，只是写了一个针对斗地主类类游戏的牌的算法，包含了牌模型构建、洗牌、发牌、出牌等算法的实现，虽然游戏规则不同，但是思路大同小异，希望有需要的同学可以参考下。</p>]]></content>
    
    
    <summary type="html">斗地主算法</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
    <category term="斗地主" scheme="http://example.com/tags/%E6%96%97%E5%9C%B0%E4%B8%BB/"/>
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android自动化测试——Money</title>
    <link href="http://example.com/2016/06/23/20160623Android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94Monkey/"/>
    <id>http://example.com/2016/06/23/20160623Android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94Monkey/</id>
    <published>2016-06-23T10:34:46.000Z</published>
    <updated>2020-12-09T06:33:20.700Z</updated>
    
    <content type="html"><![CDATA[<p>之前有和公司同事一起研究过Android的一些自动化测试工具，当时记得花费了大半天时间去研究怎么使用，但是却忘记整理了，趁着最近不太忙，整理下Android的自动化测试工具吧。</p><p>当前最常用的Android自动化测试工具主要有以下几个：</p><ol><li><p>Monkey：    <a href="https://developer.android.com/studio/test/monkey.html">主页地址(Google)</a></p></li><li><p>MonkeyRunner：  <a href="https://developer.android.com/studio/test/monkeyrunner/index.html">主页地址(Google)</a></p></li><li><p>Robotium：    <a href="https://github.com/RobotiumTech/robotium">主页地址(Git)</a></p></li></ol><p>这三个中，Monkey和MonkeyRunner均在Google的开发者中心有介绍，上边也有给出连接，需要翻墙，下边将逐个进行介绍。</p><h3 id="1-Monkey"><a href="#1-Monkey" class="headerlink" title="1.Monkey"></a>1.Monkey</h3><p>Monkey是Android系统自带的测试工具，谷歌官方给出的介绍是：Monkey是一款可以运行在虚拟机或是真机上的测试程序，主要原理是通过发送一系列的伪随机流事件，模拟用户点击滑动等操作，测试应用程序的健壮性。</p><h4 id="1-1-Monkey命令"><a href="#1-1-Monkey命令" class="headerlink" title="1.1 Monkey命令"></a>1.1 Monkey命令</h4><p>Monkey的使用方法比较简单，使用adb连接上客户端以后，可以直接使用Monkey命令进行测试</p><p><img src="http://image.jucaiwy.com/image/20160623/SiXKOPD.png"></p><p>图中红线圈出来的为一些常用命令：</p><ol><li><p>-p指定应用程序包名</p></li><li><p>–pct-touch指定输入touch事件所占百分比</p></li><li><p>–pct-trackball指定输入轨迹事件所占百分比</p></li><li><p>-s种子，生成伪随机数的Seed，两次Monkey的Seed一致时，将产生相同的随机事件</p></li><li><p>–throttle每一次事假与下一次事件之间的延时，单位为毫秒</p></li></ol><h4 id="1-2-Monkey使用方法"><a href="#1-2-Monkey使用方法" class="headerlink" title="1.2 Monkey使用方法"></a>1.2 Monkey使用方法</h4><p>为了更加清晰的演示Monkey的随机事件，我写了一个简单的画板，这样每一次输入，将会直观的呈现在屏幕上。画板测试代码：我是测试画板</p><p><img src="http://image.jucaiwy.com/image/20160623/942rGkm.png"></p><p>上图为Monkey基本命令使用方法，分为两步：</p><ol><li>使用adb shell 连接客户端</li><li>执行monkey命令</li></ol><p>其中 </p><ol><li><p><strong>-p</strong> 指定我需要测试的应用的包名：com.xinwei.test.monkey 如果没有安装这个应用，也可以直接使用系统自带的计算器进行测试，更加直观。系统计算器包名:com.android.calculator2</p></li><li><p><strong>–pct-motion 100</strong> 表示输入事件中动作事件占100%</p></li><li><p><strong>throttle</strong> 延时 200毫秒，即每一次动作之间均延时200ms</p></li><li><p><strong>1000</strong> 最后一位 一千次随机事件</p></li></ol><p>当然，也可以不指定包名输入事件等，只需要指定随机事件个数，试试吧，有惊喜的。</p><h3 id="1-3-测试结果"><a href="#1-3-测试结果" class="headerlink" title="1.3 测试结果"></a>1.3 测试结果</h3><p>使用上述命令，测试自定义画板应用，设置输入事件全部为动作事件，结果如下：</p><p><img src="http://image.jucaiwy.com/image/20160623/itdOHEF.gif"></p><p>当没有指定事件类型时，即输入事件全部为随机事件时：</p><p><img src="http://image.jucaiwy.com/image/20160623/pvaNYeI.gif"></p>]]></content>
    
    
    <summary type="html">Android自动化测试——Money</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
    <category term="自动化测试" scheme="http://example.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    <category term="Monkey" scheme="http://example.com/tags/Monkey/"/>
    
  </entry>
  
  <entry>
    <title>Android自动化测试——MoneyRunner</title>
    <link href="http://example.com/2016/06/23/20160623Android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94MonkeyRunner/"/>
    <id>http://example.com/2016/06/23/20160623Android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E2%80%94%E2%80%94MonkeyRunner/</id>
    <published>2016-06-23T10:34:46.000Z</published>
    <updated>2020-12-09T06:34:26.300Z</updated>
    
    <content type="html"><![CDATA[<p>接着上一篇文章继续写，上篇文章中，主要对<a href="http://blog.csdn.net/duanbokan/article/details/51742893">Android自动化测试——Monkey</a>的概念和使用方法进行了简单介绍，，这篇文章中，我们继续探讨MonkeyRunner的使用</p><p>有人之前问过我，Monkey和MonkeyRunner之间有什么区别，我用这样一个比喻来回答他，Monkey就是一只猴子，放养的猴子，未经训练的猴子，所以它在测试的时候，只会胡乱点、胡乱划(随机事件)；而MonkeyRunner则不同于Monkey，它属于家养的，经过训练的，可以按照主人的命令，做出各种动作(自定义事件)。</p><p>ok，下边直接讲如何使用MonkeyRunner</p><h3 id="1-1-MonkeyRunner环境搭建"><a href="#1-1-MonkeyRunner环境搭建" class="headerlink" title="1.1 MonkeyRunner环境搭建"></a>1.1 MonkeyRunner环境搭建</h3><p>搭建MonKeyRunner环境需要以下三部分：</p><ol><li><p>Java环境，及Java环境变量配置</p></li><li><p>Android SDK Monkey是Google提供的自动化测试工具，在SDK根路径的tools文件夹中可以找到，因此，使用MonkeyRunner需要下载安装SDK。 下载完成后，直接解压，绿色，无需安装，注意解压路径不能有中文或空格。</p><p> <a href="http://www.android-doc.com/sdk/index.html">SDK下载路径</a></p></li><li><p>安装Python编译环境  ：Python用于支持MonkeyRunner的运行，安装Python，同时配置其环境变量。</p><p> <a href="https://www.python.org/downloads/">Python下载路径</a></p></li></ol><p>检查Python和MonkeyRunner是否配置正确：</p><p><img src="http://i.imgur.com/liqPDX8.png"></p><h3 id="1-2-录制脚本"><a href="#1-2-录制脚本" class="headerlink" title="1.2 录制脚本"></a>1.2 录制脚本</h3><p>与其他自动化测试工具相似，MonkeyRunner也可以进行脚本录制。这里需要使用Python命令打开MonkeyRunner脚本录制界面：</p><p><strong>第一步</strong>： 新建文本文档，命名为record.py，编辑其内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> com.android.monkeyrunner <span class="keyword">import</span> MonkeyRunner <span class="keyword">as</span> mr  </span><br><span class="line"><span class="keyword">from</span> com.android.monkeyrunner.recorder <span class="keyword">import</span> MonkeyRecorder <span class="keyword">as</span> recorder  </span><br><span class="line">      </span><br><span class="line">device = mr.waitForConnection()  </span><br><span class="line">recorder.start(device) </span><br></pre></td></tr></table></figure><p>编辑完成后，将该文件放在monkeyrunner平级的目录下(这里注明放在和SDK平级的目录下，是为了方便执行，不用输入绝对路径)，即 <strong>E:\Android\sdk\tools</strong>(注意自己的SDK路径)</p><p><strong>第二步</strong>： 在cmd命令行，执行该文件：</p><p><img src="http://image.jucaiwy.com/image/20160623/monkey/glI0yVI.png"></p><p>执行成功后，会出现MonkeyRunner的录制界面：</p><p><img src="http://image.jucaiwy.com/image/20160623/monkey/2wgySa6.png"></p><p>界面中：</p><ol><li>左侧为当前屏幕界面</li><li>右侧为当前操作类型及位置</li><li>标题栏中：<ol><li>Wait:设置输入时间间隔，单位为秒</li><li>Press a Button: 硬件按钮，包括menu、home、search，以及对按钮的press、down、up属性</li><li>Type Something: 输入内容</li><li>Fling: 滑动输入，可设置方向和操作范围</li><li>Export Actions:导出录制脚本</li><li>Refresh Display:界面刷新，或者叫做界面同步</li></ol></li></ol><p>至此，已经学会了如何使用MonkeyRunner进行脚本录制，接下来将如何回放录制的脚本。<br>我们仍然使用之前的自定义画板进行录制（因为之前画板代码存在问题，没有绘制点，只是绘制线，因此需要输入滑动事件），我们使用MonkeyRecoder的Fling功能，随便绘制两条线，结果如下：</p><p><img src="http://image.jucaiwy.com/image/20160623/monkey/BzLeUro.png"></p><p>左侧为绘制线条，右侧为动作，录制完成后，可以将脚本导出并保存。</p><h3 id="1-3-脚本回放"><a href="#1-3-脚本回放" class="headerlink" title="1.3 脚本回放"></a>1.3 脚本回放</h3><p>使用MonkeyRecoder录制完脚本后，可以对脚本进行回放。</p><p>回放时，需要使用MonkeyRunner执行Python脚本，内容固定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> com.android.monkeyrunner <span class="keyword">import</span> MonkeyRunner</span><br><span class="line">CMD_MAP = &#123;</span><br><span class="line"><span class="string">&#x27;TOUCH&#x27;</span>: <span class="keyword">lambda</span> dev, arg: dev.touch(**arg),</span><br><span class="line"><span class="string">&#x27;DRAG&#x27;</span>: <span class="keyword">lambda</span> dev, arg: dev.drag(**arg),</span><br><span class="line"><span class="string">&#x27;PRESS&#x27;</span>: <span class="keyword">lambda</span> dev, arg: dev.press(**arg),</span><br><span class="line"><span class="string">&#x27;TYPE&#x27;</span>: <span class="keyword">lambda</span> dev, arg: dev.<span class="built_in">type</span>(**arg),</span><br><span class="line"><span class="string">&#x27;WAIT&#x27;</span>: <span class="keyword">lambda</span> dev, arg: MonkeyRunner.sleep(**arg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Process a single file for the specified device.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_file</span>(<span class="params">fp, device</span>):</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fp:</span><br><span class="line">(cmd, rest) = line.split(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment"># Parse the pydict</span></span><br><span class="line">rest = <span class="built_in">eval</span>(rest)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;unable to parse options&#x27;</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cmd <span class="keyword">not</span> <span class="keyword">in</span> CMD_MAP:</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;unknown command: &#x27;</span> + cmd</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">CMD_MAP[cmd](device, rest)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">file = sys.argv[<span class="number">1</span>]</span><br><span class="line">fp = <span class="built_in">open</span>(file, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">device = MonkeyRunner.waitForConnection()</span><br><span class="line">process_file(fp, device)</span><br><span class="line">fp.close();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>同样的操作，新建python文档，将这个脚本粘贴至该文档中，文档路径与MonkeyRunner路径相同(避免使用绝对路径进行操作)</p><p>然后执行该脚本，得到结果与之前绘制效果一致。</p><p><img src="http://image.jucaiwy.com/image/20160623/monkey/GluioC1.gif"></p><h3 id="1-4-自定义脚本"><a href="#1-4-自定义脚本" class="headerlink" title="1.4 自定义脚本"></a>1.4 自定义脚本</h3><p>对之前录制脚本文件使用编辑器打开，会发现，生成脚本其实就是一系列语句，所以我们可以对该脚本进行修改，完成自定义，下面我们通过修改脚本，绘制一个正方形，修改后脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WAIT|&#123;<span class="string">&#x27;seconds&#x27;</span>:<span class="number">5.0</span>,&#125; </span><br><span class="line">DRAG|&#123;<span class="string">&#x27;start&#x27;</span>:(<span class="number">100</span>,<span class="number">100</span>),<span class="string">&#x27;end&#x27;</span>:(<span class="number">100</span>,<span class="number">1000</span>),<span class="string">&#x27;duration&#x27;</span>:<span class="number">1.0</span>,<span class="string">&#x27;steps&#x27;</span>:<span class="number">10</span>,&#125;</span><br><span class="line">DRAG|&#123;<span class="string">&#x27;start&#x27;</span>:(<span class="number">100</span>,<span class="number">1000</span>),<span class="string">&#x27;end&#x27;</span>:(<span class="number">1000</span>,<span class="number">1000</span>),<span class="string">&#x27;duration&#x27;</span>:<span class="number">1.0</span>,<span class="string">&#x27;steps&#x27;</span>:<span class="number">10</span>,&#125;</span><br><span class="line">WAIT|&#123;<span class="string">&#x27;seconds&#x27;</span>:<span class="number">1.0</span>,&#125; </span><br><span class="line">DRAG|&#123;<span class="string">&#x27;start&#x27;</span>:(<span class="number">1000</span>,<span class="number">1000</span>),<span class="string">&#x27;end&#x27;</span>:(<span class="number">1000</span>,<span class="number">100</span>),<span class="string">&#x27;duration&#x27;</span>:<span class="number">1.0</span>,<span class="string">&#x27;steps&#x27;</span>:<span class="number">10</span>,&#125;</span><br><span class="line">DRAG|&#123;<span class="string">&#x27;start&#x27;</span>:(<span class="number">1000</span>,<span class="number">100</span>),<span class="string">&#x27;end&#x27;</span>:(<span class="number">100</span>,<span class="number">100</span>),<span class="string">&#x27;duration&#x27;</span>:<span class="number">1.0</span>,<span class="string">&#x27;steps&#x27;</span>:<span class="number">10</span>,&#125;</span><br></pre></td></tr></table></figure><p>回放该脚本：</p><p><img src="http://image.jucaiwy.com/image/20160623/monkey/6KGGXc2.gif"></p><p>这里仅仅只是用了DRAG和WAIT两个动作。同样的还有很多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PRESS|&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;MENU&#x27;</span>,<span class="string">&#x27;type&#x27;</span>:<span class="string">&#x27;downAndUp&#x27;</span>,&#125;</span><br><span class="line">PRESS|&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;HOME&#x27;</span>,<span class="string">&#x27;type&#x27;</span>:<span class="string">&#x27;downAndUp&#x27;</span>,&#125;</span><br><span class="line">PRESS|&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;SEARCH&#x27;</span>,<span class="string">&#x27;type&#x27;</span>:<span class="string">&#x27;downAndUp&#x27;</span>,&#125;</span><br><span class="line">PRESS|&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;MENU&#x27;</span>,<span class="string">&#x27;type&#x27;</span>:<span class="string">&#x27;down&#x27;</span>,&#125;</span><br><span class="line">TYPE|&#123;<span class="string">&#x27;message&#x27;</span>:<span class="string">&#x27;hello&#x27;</span>,&#125;</span><br><span class="line">TOUCH|&#123;<span class="string">&#x27;x&#x27;</span>:<span class="number">469</span>,<span class="string">&#x27;y&#x27;</span>:<span class="number">836</span>,<span class="string">&#x27;type&#x27;</span>:<span class="string">&#x27;downAndUp&#x27;</span>,&#125;</span><br></pre></td></tr></table></figure><h2 id="2-结束"><a href="#2-结束" class="headerlink" title="2. 结束"></a>2. 结束</h2><p>至此已经大致讲完了MonkeyRunner的基本使用方法，至于后边想到什么了，记得使用MonkeyRunner时有个takePicture的命令，想起来了再进行补充吧。</p>]]></content>
    
    
    <summary type="html">Android自动化测试——MoneyRunner</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
    <category term="自动化测试" scheme="http://example.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    <category term="MonkeyRunner" scheme="http://example.com/tags/MonkeyRunner/"/>
    
  </entry>
  
  <entry>
    <title>Android更新机制（自己服务器和GooglePlay更新）</title>
    <link href="http://example.com/2016/05/13/20160513Android%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2016/05/13/20160513Android%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6/</id>
    <published>2016-05-13T10:34:46.000Z</published>
    <updated>2020-12-09T06:32:43.010Z</updated>
    
    <content type="html"><![CDATA[<p>本片文章主要介绍了自己服务器更新和GooglePlay更新的解决方案，不包含其他第三方（如Umeng、其他应用市场等）更新。之所以要区分GooglePlay更新和自己搭建服务器更新，是因为GooglePlay在13年修改其开发者中心对Dangerous Products的定义时，有提示如下文字：</p><p>   <img src="http://image.jucaiwy.com/image/20150513/update_title.png"></p><p>即：凡是从GooglePlay中下载的应用，不得GooglePlay的更新机制，自行更改、替换、升级Apk二进制代码。因此对于在GooglePlay上线的应用，只能交由GooglePlay维护版本更新。</p><p>这样，我们在开发过程中，若使用自己搭建服务器维护更新的，需要对自己服务器版本和GooglePlay版本进行区分。包括<strong>打包</strong>和<strong>更新</strong>区分。</p><h3 id="更新机制"><a href="#更新机制" class="headerlink" title="更新机制"></a>更新机制</h3><p>我们在自己的应用中，使用如下更新机制</p><p><img src="http://image.jucaiwy.com/image/20150513/update1.png"></p><p>总的来说，自己服务器需要配置三个信息，</p><ol><li>当前最新版本号</li><li>是否强制更新（不建议使用强制更新，用户体验实在太差）</li><li>CooGame服务端最新版本下载地址</li></ol><p>检测更新步骤</p><ol><li>无论GooglePlay版本还是CooGame版本，打开时均从CooGame版本请求最新版本信息，返回最新版本号和下载地址</li><li>当发现有新版本时，提示用户</li><li>用户选择更新后，CooGame版本直接从返回的下载地址中下载文件。GooglePlay则是打开GooglePlay商店，若打开失败，则启动一个WebView，打开该软件在GooglePlay上的地址。</li><li>更新完成</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在开发过程中，注意服务端的版本兼容，尽量避免出现强制更新的情况。</p>]]></content>
    
    
    <summary type="html">Android更新机制（自己服务器和GooglePlay更新）</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="App更新" scheme="http://example.com/tags/App%E6%9B%B4%E6%96%B0/"/>
    
    <category term="Google更新" scheme="http://example.com/tags/Google%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android升级6.0后使用Https请求出现Handshake failed错误</title>
    <link href="http://example.com/2016/04/29/20160317Android6.0%E6%8F%A1%E6%89%8B%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2016/04/29/20160317Android6.0%E6%8F%A1%E6%89%8B%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</id>
    <published>2016-04-29T10:34:46.000Z</published>
    <updated>2020-12-09T06:30:57.610Z</updated>
    
    <content type="html"><![CDATA[<p>昨天手残，使用HTC M8升级了一下最新系统，Android6.0版本的，升级后，在测试我们的应用时，突然出现握手失败错误：</p><p><img src="http://image.jucaiwy.com/image/20160317/FPf2n91.png"></p><p>即显示握手失败，但是在Android6.0以下版本中，并没有出现该问题。</p><h3 id="一、Android6-0的一些修改"><a href="#一、Android6-0的一些修改" class="headerlink" title="一、Android6.0的一些修改"></a>一、Android6.0的一些修改</h3><p>因为该问题仅仅出现在Android6.0版本中，因此，考虑是由版本升级引起的。查看Google给出的Android6.0修改文档，发现以下两点：</p><p><img src="http://image.jucaiwy.com/image/20160317/CMFFR7g.png"></p><p>即：</p><ol><li>从Android6.0之后将不再支持HttpClient的使用，建议使用HttpURLConnection代替。</li><li>Android6.0之后，在Https请求中，SSL层将不再使用OpenSSL协议，改用自己的BoringSSL协议</li></ol><h3 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h3><h4 id="2-1-取消HttpClient"><a href="#2-1-取消HttpClient" class="headerlink" title="2.1 取消HttpClient"></a>2.1 取消HttpClient</h4><p>在我们的项目中使用的是HttpClient执行Https请求，但是官方升级只是在API文档中删除了HttpClient相关的文件，但是并不影响其使用，用户可以通过以下两种方法继续使用：</p><ol><li><p>使用Android6.0进行编译，则需要添加 org.apache.http.legacy.jar,文件目录：SDK\platforms\android-23\optional；或者是在AndroidStudio中的build.gradle文件中加入：<strong>android {useLibrary ‘org.apache.http.legacy’}</strong></p></li><li><p>使用Android6.0以下版本进行编译。</p></li></ol><p>因此，排除该可能。</p><h4 id="2-2-使用BoringSSL替换OpenSSL"><a href="#2-2-使用BoringSSL替换OpenSSL" class="headerlink" title="2.2 使用BoringSSL替换OpenSSL"></a>2.2 使用BoringSSL替换OpenSSL</h4><p>因为考虑到是该问题引起的，因此回过头重新对握手失败原因进行查看，发现在之前Log结尾部分忽略了一句话，也正是因为忽略这句话，导致之前思维一直停在可能是HttpClient被取消导致的，浪费了很多时间，握手失败后，在最后边Log中，出现这样的信息：</p><p><img src="http://image.jucaiwy.com/image/20160317/zUP4Cli.png"></p><p>关键字：<strong>BAD_DH_P_LENGTH</strong> </p><p>经过一番寻找，发现意思应该是Diffie-Hellman的p参数长度错误。主要参考文章：<a href="http://bbs.csdn.net/topics/391843187">谢谢大神——连接</a></p><p>通过对帖子的阅读和资料的查找，总结其主要原因在于：</p><p>Https建立连接之前，会进行多次握手，即单向认证和双向认证。在该过程中，客户端会将自己支持的所有加密方式发送给服务端，供服务端选择，服务端选择好加密程度较高的加密方式后，会以明文或者是客户端私钥加密密文的方式发送给客户端。</p><p>具体认证过程可参考我的上一篇文章：<a href="http://blog.csdn.net/duanbokan/article/details/50847612">Https单向认证和双向认证</a></p><p>在握手过程中，必定会涉及到公钥加密，私钥解密的过程，而该过程中，当服务端选择使用诸如<code>TLS_DHE_RSA_WITH_AES_128_CBC_SHA</code>等算法进行加密时，需要使用到<a href="http://baike.baidu.com/link?url=bXqyg5o-fpDYcqQ753nR659lJcU9TTxS9dP2SDxUVSHS_b0BURjiMAkBsQbocBDX9OMb0gosZHgsT9_Hlszt-q">Diffie-Hellman</a>算法进行加密解密，通过阅读Diffie-Hellman算法的介绍，发现在加密解密计算过程中，会使用到两个参数，一个是q，一个是a，而在JDK8之前，服务器端提供的q参数只是用了768bit的长度，而不足1024bit则存在相应的安全漏洞，会被替换后的BroingSSL拒绝，因此出现了Handshake failed错误。</p><p>终于找到问题所在了,总结这个纠结的过程，我只想说：一定要认真看Log！！！</p><h3 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h3><p>通过阅读上边提到的大神写的帖子，发现两种可以解决的办法：</p><ol><li><p>升级JDK到8(条件限制，未经过测试)</p></li><li><p>配置Tomcat服务器，限制加密方式：</p><p> 修改Tomcat服务器conf&#x2F;server.xml文件中和Https有关的Connector节点，添加ciphers用于指定密钥：</p><pre><code> &lt;Connector      SSLEnabled=&quot;true&quot;      clientAuth=&quot;false&quot;      connectionTimeout=&quot;20000&quot;      keystoreFile=&quot;/usr/xinwei/tienlen/apache-tomcat-https/server.keystore&quot;      keystorePass=&quot;xinwei&quot;      maxThreads=&quot;150&quot;      port=&quot;443&quot;      protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot;      redirectPort=&quot;8443&quot;      scheme=&quot;https&quot;      secure=&quot;true&quot;      ciphers=&quot;TLS_RSA_WITH_AES_128_CBC_SHA256,       TLS_RSA_WITH_AES_128_CBC_SHA,       TLS_RSA_WITH_AES_256_CBC_SHA256,       TLS_RSA_WITH_AES_256_CBC_SHA,       SSL_RSA_WITH_3DES_EDE_CBC_SHA&quot;     sslProtocol=&quot;TLS&quot;      truststoreFile=&quot;/usr/xinwei/tienlen/apache-tomcat-https/server.keystore&quot;      truststorePass=&quot;密码&quot; /&gt;</code></pre></li></ol><p>添加完该配置后，重启，测试，Android6.0版本没有再发现Handshake failed错误。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>这篇文章主要是记录了我解决该问题的过程和方法，没什么特别多的原创。主要是在原文作者的基础上，更深入的解释了一下出现该错误的原因。</p><p>同时也因为我的疏忽，浪费了大量时间，引以为戒。</p>]]></content>
    
    
    <summary type="html">Android升级6.0后使用Https请求出现Handshake failed错误</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    <category term="问题记录" scheme="http://example.com/categories/Android/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
    <category term="HTTP" scheme="http://example.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Android使用CRC校验</title>
    <link href="http://example.com/2016/04/29/20160429Android%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BD%BF%E7%94%A8CRC%E6%A0%A1%E9%AA%8C/"/>
    <id>http://example.com/2016/04/29/20160429Android%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BD%BF%E7%94%A8CRC%E6%A0%A1%E9%AA%8C/</id>
    <published>2016-04-29T10:34:46.000Z</published>
    <updated>2020-12-09T06:32:16.130Z</updated>
    
    <content type="html"><![CDATA[<p>最近手头的一个项目，客户端和服务端之间进行通讯时，由于受到当地网络等问题的限制，使用Json传输，数据内容过于庞大，需要对该信息进行压缩，以便实现快速传输。这里使用Byte数组进行传输，前后台对协议进行商定，而后编码、传输、解码实现通信，传输过程中，为保证传输内容的完整性，需要使用CRC进行校验。</p><h3 id="CRC概念——百度百科"><a href="#CRC概念——百度百科" class="headerlink" title="CRC概念——百度百科"></a>CRC概念——百度百科</h3><p>CRC即循环冗余校验码（Cyclic Redundancy Check[1]  ）：是数据通信领域中最常用的一种查错校验码，其特征是信息字段和校验字段的长度可以任意选定。循环冗余检查（CRC）是一种数据传输检错功能，对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。</p><h3 id="CRC编码"><a href="#CRC编码" class="headerlink" title="CRC编码"></a>CRC编码</h3><p>编码：根据传输内容逐位计算，得到CRC编码，附加在该Byte数组后边。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 为Byte数组添加两位CRC校验</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> buf</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] setParamCRC(<span class="type">byte</span>[] buf) &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">MASK</span> <span class="operator">=</span> <span class="number">0x0001</span>, CRCSEED = <span class="number">0x0810</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">remain</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">byte</span> val;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buf.length; i++) &#123;</span><br><span class="line">           val = buf[i];</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (((val ^ remain) &amp; MASK) != <span class="number">0</span>) &#123;</span><br><span class="line">                   remain ^= CRCSEED;</span><br><span class="line">                   remain &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                   remain |= <span class="number">0x8000</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   remain &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               val &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">byte</span>[] crcByte = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">       crcByte[<span class="number">0</span>] = (<span class="type">byte</span>) ((remain &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">       crcByte[<span class="number">1</span>] = (<span class="type">byte</span>) (remain &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将新生成的byte数组添加到原数据结尾并返回</span></span><br><span class="line">       <span class="keyword">return</span> concatAll(buf, crcByte);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="CRC解码"><a href="#CRC解码" class="headerlink" title="CRC解码"></a>CRC解码</h3><p>在服务端接受到客户端传输过来的byte数组，然后先进行CRC校验，通过后，才能确定数据在传输过程中未发生改变，才能进行下一步业务操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/***</span></span><br><span class="line"><span class="comment"> * CRC校验是否通过</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcByte</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPassCRC</span><span class="params">(<span class="type">byte</span>[] srcByte, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 取出除crc校验位的其他数组，进行计算，得到CRC校验结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">calcCRC</span> <span class="operator">=</span> calcCRC(srcByte, <span class="number">0</span>, srcByte.length - length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出CRC校验位，进行计算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">receive</span> <span class="operator">=</span> toInt(getBytesByindex(srcByte, srcByte.length - length, srcByte.length - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较</span></span><br><span class="line"><span class="type">return</span> <span class="variable">calcCRC</span> <span class="operator">=</span>= receive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这中间  计算CRC的方法和之前的基本是一致的。只是第二步中，取到两位CRC校验值以后，将其转为int，然后进行比较</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>这里有一个我写的CRC校验的Demo，没有使用jar包，可以进行修改。</p><p><a href="http://download.csdn.net/detail/duanbokan/9506690">CRC校验Demo</a></p>]]></content>
    
    
    <summary type="html">Android使用CRC校验</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
    <category term="CRC" scheme="http://example.com/tags/CRC/"/>
    
  </entry>
  
  <entry>
    <title>在AndroidStudio中使用Eclipse下的CodeFormates和CodeTemplates</title>
    <link href="http://example.com/2016/04/22/20160422AndroidStudio%E4%B8%AD%E4%BD%BF%E7%94%A8Eclipse%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2016/04/22/20160422AndroidStudio%E4%B8%AD%E4%BD%BF%E7%94%A8Eclipse%E9%85%8D%E7%BD%AE/</id>
    <published>2016-04-22T10:34:46.000Z</published>
    <updated>2020-12-09T06:31:57.050Z</updated>
    
    <content type="html"><![CDATA[<p>换Eclipse为AndroidStudio后，需要将之前Eclipse中的CodeStyle和Formatter导入AndroidStudio中使用。具体操作步骤如下：</p><h3 id="导入Formatter"><a href="#导入Formatter" class="headerlink" title="导入Formatter"></a>导入Formatter</h3><p>想要在AndroidStudio中使用Eclipse风格的Formatter，首先需要安装插件：</p><ol><li>点击File——&gt;Setting</li></ol><p><img src="http://i.imgur.com/7hxJGk8.png"></p><ol start="2"><li>在打开的Setting界面中，点击Plugins，然后在搜索框中输入Eclipse Code Formatter，搜索结果中点击安装（因为我之前已经安装过了，所以这里只显示Uninstall）</li></ol><p><img src="http://i.imgur.com/yhdJ8iy.png"></p><ol start="3"><li>安装完毕后，再次打开File——&gt;Setting，会出现Eclipse Code Formatter 选项，一般在OtherSetting中，若没有可以使用上边的搜索框进行搜索。</li><li>打开后，选择 Use the Eclipse code formatter 然后在下边的Eclipse Java Formatter config file中设置自己Formatter的文件路径，然后点击Apply，即可生效。</li></ol><p><img src="http://i.imgur.com/tL8oWxu.png"></p><ol start="5"><li>配置完成后，需要进行激活才能使用Eclipse的Formatter，如图，将该图标切换至Eclipse图标，即表示当前使用Eclipse进行Formatter。且每一次Formatter，均会打印一条Log</li></ol><p><img src="http://i.imgur.com/j3Xu95R.png"></p><h3 id="使用CodeTemplates"><a href="#使用CodeTemplates" class="headerlink" title="使用CodeTemplates"></a>使用CodeTemplates</h3><p>找了半天，都没有找到直接导入Eclipse下CodeTemplates文件的方法，所以，只能自己动手去写了，现在只是找到了，如何为新建的java类添加注释，其余方法，愿大家共同探讨。</p><p><img src="http://i.imgur.com/khPnucm.png"></p><p>这里，需要说明一下，不知道是不是我打开的方式不对，这里添加CopyRight后，需要每一次都Generate一下，才会在文件中生成，不知道有没有自动Generate的，这样就不需要添加HeadFile了</p><h3 id="直接导入"><a href="#直接导入" class="headerlink" title="直接导入"></a>直接导入</h3><p>除了上述两个方法之外，当然也可以直接导入我自己已经配置好的配置文件，文件会在附件中出现，如图，进行导入</p><p><img src="http://i.imgur.com/dVHhUKU.png"></p><p>当然导入时，可以不选择UI之类的东西，因为个人喜好么。</p>]]></content>
    
    
    <summary type="html">在AndroidStudio中使用Eclipse下的CodeFormates和CodeTemplates</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
    <category term="Eclipse" scheme="http://example.com/tags/Eclipse/"/>
    
  </entry>
  
  <entry>
    <title>Android下使用Protobuf进行序列化</title>
    <link href="http://example.com/2016/03/31/20160331Android%E4%B8%8B%E4%BD%BF%E7%94%A8Protobuf%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://example.com/2016/03/31/20160331Android%E4%B8%8B%E4%BD%BF%E7%94%A8Protobuf%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2016-03-31T10:34:46.000Z</published>
    <updated>2020-12-09T06:31:31.430Z</updated>
    
    <content type="html"><![CDATA[<p>Protocol Buffer是Google发起的，一个语言无关、平台无关的序列化&#x2F;反序列化结构化数据的通用机制（框架），可用于通信协议，数据存储等。</p><p>近期在做一柬埔寨的小项目，上线后在运行过程中，总是有用户反映应用在网络请求时，速度较慢，影响用户体验。对该问题结合使用环境及代码进行分析，发现存在以下问题：</p><ol><li>App中使用Json进行数据传输，存在很多冗余字段的传输，而且经过查阅资料，Json对数据进行序列化以后，数据包仍然很大。</li><li>柬埔寨存在网络信号问题，很多情况下，信号较差，大数据包的传输存在压力</li></ol><p>综合来说，网络环境不稳定和传输数据包过大应该是导致网络请求过程中吃力、或者是超时的主要原因，因此，在优化时，主要考虑如何压缩传输过程中数据包。</p><h3 id="1-什么是Protobuf"><a href="#1-什么是Protobuf" class="headerlink" title="1. 什么是Protobuf"></a>1. 什么是Protobuf</h3><p>protobuf，全称：Google Protocol Buffer，是Google开源的一种轻便高效的结构化数据存储格式，可以用于结构化数据的串行化，也称作序列化，主要用于数据存储或是RPC数据交换，支持多语言，可拓展</p><h3 id="2-项目主页"><a href="#2-项目主页" class="headerlink" title="2. 项目主页"></a>2. 项目主页</h3><p>protobuf主页：   <a href="https://developers.google.com/protocol-buffers/">主页地址</a></p><p>protobuf下载(Java)： <a href="https://developers.google.com/protocol-buffers/docs/downloads#release-packages">下载地址</a></p><p>protobuf Github：   <a href="https://github.com/google/protobuf">Git地址</a></p><h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h3><p>因为Android环境下使用Java语言进行开发，因此我们选择Java版本进行下载。</p><p>首先需要到Protobuf主页上下载最新的源码包：<a href="https://github.com/google/protobuf/releases/download/v2.6.1/protobuf-2.6.1.tar.gz">下载地址</a></p><p>或者是下载Google打包好的Windows下可执行文件：<a href="https://github.com/google/protobuf/releases/download/v2.6.1/protoc-2.6.1-win32.zip">下载地址</a></p><h4 id="3-1-源码编译"><a href="#3-1-源码编译" class="headerlink" title="3.1 源码编译"></a>3.1 源码编译</h4><p>首先，在Eclipse中开发，需要引入protobuf需要的Jar包，而官方只给出了相应源码，因此需要自己进行编译。编译方法如下：</p><ol><li>安装Maven环境，具体安装过程，参考网上：<a href="http://jingyan.baidu.com/article/295430f136e8e00c7e0050b9.html">连接</a></li><li>安装好Maven后，需要进行编译，才能生成需要引入的Jar文件，具体操作为：首先将下载好的protoc.exe文件复制到\protobuf-2.6.1\src目录下。然后进入protobuf-2.6.1\java目录下，直接运行命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure><p>如下：</p><p> <img src="http://image.jucaiwy.com/image/20160331/D14jNhV.png"></p><pre><code>编译完成后，会在\protobuf-2.6.1\java\target\目录下生成文件：protobuf-java-2.6.1.jar。可以直接导入Eclipse中进行使用</code></pre><h4 id="3-2-构建对象"><a href="#3-2-构建对象" class="headerlink" title="3.2 构建对象"></a>3.2 构建对象</h4><p>即定义数据模型，需要新建一个文件，后缀名为.proto,例如，我需要生成对象如下：</p><pre><code>public class ProductInfo&#123;    private String productID;        private String productName;        private String productAmount;        private String productDate;        private String productMessage;&#125;</code></pre><p>需要按照以下步骤进行</p><ol><li><p>新建文件，名为：ProductInfo.proto</p></li><li><p>使用UE或者NotePad++等编辑软件打开该文件，对需要录入的字段进行编辑，如下(UE直接写出来，太难排版了，只能上图)</p><p> <img src="http://image.jucaiwy.com/image/20160331/7hiJIcM.png"></p></li></ol><p>说明：该文件中：</p><ul><li>java_package：包名</li><li>java_outer_classname：类名</li><li>ProductInfo：对象名</li><li>required：必须有值</li><li>optional：可以不写值</li><li>string：相当于Java中的String</li><li>int32：相当于Java中的int</li></ul><p>具体proto文件类型、Java类型及C++类型对比如下：</p><p><img src="http://image.jucaiwy.com/image/20160331/hF1WG8K.png"></p><p>具体还可以参考连接： <a href="http://www.cnblogs.com/dkblog/archive/2012/03/27/2419010.html"> Protobuf语言指南</a></p><ol start="3"><li><p>使用protoc进行编译，语句为：</p><p> <strong>protoc –java_out&#x3D;E:\Android开源项目\Protobuf数据传输协议\protobuf ProductInfo.proto</strong></p></li></ol><p>注：</p><ul><li><p>protoc：指使用下载好的protoc.exe进行编译</p></li><li><p>java_out:编译器编译时，生成的语言同样的参数也可以是cpp_out</p></li><li><p>“&#x3D;” 后边内容为需要编译的文件路径和文件名</p><p>  编译完成后，会在编译文件位置相同的路径下，生成编译完成的文件，Java的以包的形式存放，即以文件夹的形式存放。</p></li></ul><p>至此，已经完成了Jar包的编译和需要传输的对象的编译，接下来举例说明如何进行使用。</p><h4 id="3-3-在Java中使用"><a href="#3-3-在Java中使用" class="headerlink" title="3.3 在Java中使用"></a>3.3 在Java中使用</h4><p>新建Android工程，将生成的Jar文件拷贝到工程目录下的libs文件夹里边，将生成的模型文件拷贝到工程中对应的包下边，可以进行创建和使用对象：</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">testProto</span><span class="params">()</span> &#123;</span><br><span class="line">    ProductInfo.Product.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> ProductInfo.Product.newBuilder();</span><br><span class="line">    builder.setAmount(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">    builder.setUid(<span class="number">10010</span>);</span><br><span class="line">    builder.setProductCode(<span class="string">&quot;Product1&quot;</span>);</span><br><span class="line">    builder.setLuckNum(<span class="string">&quot;12345&quot;</span>);</span><br><span class="line">    builder.setAllPhoneNum(<span class="string">&quot;10086&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成product对象</span></span><br><span class="line">    ProductInfo.<span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> builder.build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为Byte</span></span><br><span class="line">    <span class="type">byte</span>[] products = product.toByteArray();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反解</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">Product</span> <span class="variable">productParse</span> <span class="operator">=</span> ProductInfo.Product.parseFrom(products);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Android下使用Protobuf进行序列化</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
    <category term="Protobuf" scheme="http://example.com/tags/Protobuf/"/>
    
  </entry>
  
  <entry>
    <title>Https单双向认证</title>
    <link href="http://example.com/2016/03/10/20160310Https%E5%8D%95%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/"/>
    <id>http://example.com/2016/03/10/20160310Https%E5%8D%95%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/</id>
    <published>2016-03-10T03:54:46.000Z</published>
    <updated>2020-12-09T06:30:19.460Z</updated>
    
    <content type="html"><![CDATA[<p>Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了SSL(Secure Sockets Layer)协议用于对Http协议传输的数据进行加密，保证会话过程中的安全性。</p><h3 id="一、Http"><a href="#一、Http" class="headerlink" title="一、Http"></a>一、Http</h3><p>HyperText Transfer Protocol，超文本传输协议，是互联网上使用最广泛的一种协议，所有WWW文件必须遵循的标准。HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。</p><p>使用TCP端口为：80</p><h3 id="二、Https"><a href="#二、Https" class="headerlink" title="二、Https"></a>二、Https</h3><p>Hyper Text Transfer Protocol over Secure Socket Layer，安全的超文本传输协议，网景公式设计了SSL(Secure Sockets Layer)协议用于对Http协议传输的数据进行加密，保证会话过程中的安全性。</p><p>使用TCP端口默认为443</p><h3 id="三、SSL协议加密方式"><a href="#三、SSL协议加密方式" class="headerlink" title="三、SSL协议加密方式"></a>三、SSL协议加密方式</h3><p>SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。</p><ol><li><p>对称加密<br> 速度高，可加密内容较大，用来加密会话过程中的消息</p></li><li><p>公钥加密<br> 加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥</p></li></ol><h3 id="四、单向认证"><a href="#四、单向认证" class="headerlink" title="四、单向认证"></a>四、单向认证</h3><p>Https在建立Socket连接之前，需要进行握手，具体过程如下：</p><p><img src="http://image.jucaiwy.com/image/20160310/single.jpg" alt="这里写图片描述"></p><ol><li><p>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</p></li><li><p>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</p></li><li><p>客户端使用服务端返回的信息验证服务器的合法性，包括：</p><ul><li>证书是否过期 </li><li>发型服务器证书的CA是否可靠</li><li>返回的公钥是否能正确解开返回证书中的数字签名</li><li>服务器证书上的域名是否和服务器的实际域名相匹配</li></ul><p> 以上四条，验证通过后，将继续进行通信，否则，终止通信</p></li><li><p>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</p></li><li><p>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。</p></li><li><p>服务器将选择好的加密方案通过明文方式返回给客户端</p></li><li><p>客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器</p></li><li><p>服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</p></li></ol><h3 id="五、双向认证"><a href="#五、双向认证" class="headerlink" title="五、双向认证"></a>五、双向认证</h3><p>双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下：</p><p><img src="http://image.jucaiwy.com/image/20160310/two_way.jpg" alt="这里写图片描述"></p><ol><li><p>客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。</p></li><li><p>服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书</p></li><li><p>客户端使用服务端返回的信息验证服务器的合法性，包括：</p><ul><li>证书是否过期 </li><li>发型服务器证书的CA是否可靠</li><li>返回的公钥是否能正确解开返回证书中的数字签名</li><li>服务器证书上的域名是否和服务器的实际域名相匹配</li></ul><p> 以上四条，验证通过后，将继续进行通信，否则，终止通信</p></li><li><p>服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端</p></li><li><p>验证客户端的证书，通过验证后，会获得客户端的公钥</p></li><li><p>客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</p></li><li><p>服务器端在客户端提供的加密方案中选择加密程度最高的加密方式</p></li><li><p>将加密方案通过使用之前获取到的公钥进行加密，返回给客户端</p></li><li><p>客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端</p></li><li><p>服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。</p></li></ol>]]></content>
    
    
    <summary type="html">Https单双向认证</summary>
    
    
    
    <category term="Https" scheme="http://example.com/categories/Https/"/>
    
    
    <category term="Https" scheme="http://example.com/tags/Https/"/>
    
    <category term="Https单向认证" scheme="http://example.com/tags/Https%E5%8D%95%E5%90%91%E8%AE%A4%E8%AF%81/"/>
    
    <category term="Https双向认证" scheme="http://example.com/tags/Https%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>Linux下搭建Bouncycastle加解密环境</title>
    <link href="http://example.com/2016/03/03/20160303Linux%E4%B8%8B%E6%90%AD%E5%BB%BABouncycastle%E7%8E%AF%E5%A2%83/"/>
    <id>http://example.com/2016/03/03/20160303Linux%E4%B8%8B%E6%90%AD%E5%BB%BABouncycastle%E7%8E%AF%E5%A2%83/</id>
    <published>2016-03-03T08:31:09.000Z</published>
    <updated>2020-12-09T06:29:49.770Z</updated>
    
    <content type="html"><![CDATA[<p>Bouncycastle是一种Java平台开放源码的轻量级密码术包，可用来管理Android的证书。此次因为需要自己生成Https的证书，因此，专门学习了一下搭建Bouncycastle环境的方法，对学习过程记录如下：</p><h3 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h3><p>我使用的环境信息如下：</p><ul><li>Linux版本：CentOS 5.8 64位操作系统</li><li>Java版本：1.6.0_35</li></ul><h3 id="2-搭建步骤"><a href="#2-搭建步骤" class="headerlink" title="2. 搭建步骤"></a>2. 搭建步骤</h3><p>具体搭建步骤记录如下：</p><h4 id="2-1-下载Bouncycastle的Jar包"><a href="#2-1-下载Bouncycastle的Jar包" class="headerlink" title="2.1 下载Bouncycastle的Jar包"></a>2.1 下载Bouncycastle的Jar包</h4><p>官方网站地址是：<a href="http://www.bouncycastle.org/latest_releases.html">Bouncycastle官网</a>，网页上有两个可以下载的：</p><p>一个是crypto-154.tar.gZ(文件较小，但是我下载了以后，出现无法解压的现象，windows和linux下均无法解压)</p><p>另外一个是crypto-154.zip,推荐下载该版本，文件较大，可以直接解压得到jar文件夹，这里因为我的java版本是1.6的所以选择了<code>bcprov-debug-jdk15on-154.jar</code>。</p><p>或者也可以直接点击下载 <a href="http://www.bouncycastle.org/download/bcprov-jdk15on-146.jar">bcprov-jdk15on-146.jar</a></p><h4 id="2-2-上传下载的安装包"><a href="#2-2-上传下载的安装包" class="headerlink" title="2.2 上传下载的安装包"></a>2.2 上传下载的安装包</h4><p>将下载得到的Jar包上传到linux服务器上，找到java的根目录，将其放在jre&#x2F;lib&#x2F;ext&#x2F;目录下。如果找不到jre的路径，可以使用echo命令进行打印</p><pre><code>echo $JAVA_HOME</code></pre><p><img src="http://image.jucaiwy.com/image/20160303/bouncycastle1.png"></p><h4 id="2-3-配置"><a href="#2-3-配置" class="headerlink" title="2.3 配置"></a>2.3 配置</h4><p>修改jre&#x2F;lib&#x2F;security&#x2F;java.security文件，在其provider列表中添加一条：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">security.provider.10=org.bouncycastle.jce.provider.BouncyCastleProvider</span><br></pre></td></tr></table></figure><p>安装到此结束</p><p><img src="http://image.jucaiwy.com/image/20160303/bouncycastle2.png"></p><h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h3><p>新建Test.java文件，添加以下代码：</p><pre><code>import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;public class Test&#123;    public static final String stringToEncrypt = &quot;Thisis a test.&quot;;        public static void main(String[] args) throws Exception    &#123;        System.out.print(&quot;Attemptingto get a Blowfish key...&quot;);        KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;Blowfish&quot;);        keyGenerator.init(128);        SecretKey key = keyGenerator.generateKey();        System.out.println(&quot;OK&quot;);        System.out.println(&quot;Attemptingto get a Cipher and encrypt...&quot;);        Cipher cipher = Cipher.getInstance(&quot;Blowfish/ECB/PKCS5Padding&quot;);        cipher.init(Cipher.ENCRYPT_MODE, key);        byte[] cipherText = cipher.doFinal(stringToEncrypt.getBytes(&quot;UTF8&quot;));        System.out.println(&quot;OK&quot;);        System.out.println(&quot;Testcompleted successfully.&quot;);    &#125;&#125;</code></pre><p>当输出结果为下文时，代表搭建成功</p><pre><code>Attemptingto get a Blowfish key...OKAttemptingto get a Cipher and encrypt...OKTestcompleted successfully.</code></pre>]]></content>
    
    
    <summary type="html">Linux下搭建Bouncycastle环境</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="Bouncycast" scheme="http://example.com/tags/Bouncycast/"/>
    
    <category term="Https证书生成" scheme="http://example.com/tags/Https%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Android集成OCR实现文字识别</title>
    <link href="http://example.com/2016/02/25/20150225Android%E9%9B%86%E6%88%90OCR%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>http://example.com/2016/02/25/20150225Android%E9%9B%86%E6%88%90OCR%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/</id>
    <published>2016-02-25T10:34:46.000Z</published>
    <updated>2020-12-09T07:42:42.440Z</updated>
    
    <content type="html"><![CDATA[<p>OCR （Optical Character Recognition，光学字符识别）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程；</p><h3 id="1-Tesseract简介"><a href="#1-Tesseract简介" class="headerlink" title="1.Tesseract简介"></a>1.Tesseract简介</h3><p>Tesseract是Ray Smith于1985到1995年间在惠普布里斯托实验室开发的一个OCR引擎，曾经在1995 UNLV精确度测试中名列前茅。但1996年后基本停止了开发。2006年，Google邀请Smith加盟，重启该项目。目前项目的许可证是Apache 2.0。该项目目前支持Windows、Linux和Mac OS等主流平台。但作为一个引擎，它只提供命令行工具。<br>现阶段的Tesseract由Google负责维护，是最好的开源OCR Engine之一，并且支持中文。</p><p>主页地址：<a href="https://github.com/tesseract-ocr">https://github.com/tesseract-ocr</a></p><p>在Tesseract的主页中，我们可以下载到Tesseract的源码及语言包，常用的语言包为</p><p>中文：<a href="https://github.com/tesseract-ocr/tessdata">chi-sim.traineddata</a></p><p>英文：<a href="https://github.com/tesseract-ocr/tessdata">eng.traineddata</a></p><h3 id="2-Tess-two"><a href="#2-Tess-two" class="headerlink" title="2.Tess-two"></a>2.Tess-two</h3><p>因为Tesseract使用C++实现的，在Android中不能直接使用，需要封装JavaAPI才能在Android平台中进行调用，这里我们直接使用TessTwo项目，tess-two是TesseraToolsForAndroid的一个git分支，使用简单，切集成了leptonica，在使用之前需要先从git上下载源码进行编译。</p><h4 id="2-1-项目地址"><a href="#2-1-项目地址" class="headerlink" title="2.1 项目地址"></a>2.1 项目地址</h4><p>Tess-two在git上地址为：<a href="https://github.com/rmtheis/tess-two">https://github.com/rmtheis/tess-two</a></p><h4 id="2-2-编译"><a href="#2-2-编译" class="headerlink" title="2.2 编译"></a>2.2 编译</h4><p>我编译使用的环境：</p><ul><li>Eclipse 4.2.1</li><li>ADT 23.0.2</li><li>NDK R10</li><li>Cygwin</li></ul><p>NDK环境的具体配置及Cygwin的安装方法可以参照这篇博客：<a href="http://blog.csdn.net/pengchua/article/details/7582949">Windows下Android NDK环境搭建</a></p><p>配置好NDK环境后，将从git上下载的Tess-two进行解压，放置的路径是： E:\CooGame\OCR\TessTwo源码，下边开始进行编译：</p><ul><li>第一步：在Cygwin软件中使用cd命令打开Tesstwo的根目录。</li><li>第二步：切换到tess-two目录下的jni目录</li><li>第三步：输入命令进行编译</li></ul><p>编译需要耗费挺长时间，编译完成后，会在tess-two目录下生成libs文件夹，其中包含了编译生成的.so文件，可以进行使用。</p><p>也可以直接下载我编译好的包，这里给出下载地址，我测试了一下，是没有问题的。</p><p>tess-two下载</p><h3 id="3-tess-two使用"><a href="#3-tess-two使用" class="headerlink" title="3.tess-two使用"></a>3.tess-two使用</h3><p>编译完成后，新建工程，将之前编译好的libs文件夹下的armeabi和armeabi-v7a文件夹拷贝至新建工程的libs文件夹下，将tess-two工程中src文件夹下的两个包直接拷贝至代码中或者打成jar进行使用。工程如下：</p><p>识别函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 识别图片中文字,需要放入异步线程中进行执行</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bitmap</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">parseImageToString</span><span class="params">(String imagePath)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       <span class="comment">// 检验图片地址是否正确</span></span><br><span class="line">       <span class="keyword">if</span> (imagePath == <span class="literal">null</span> || imagePath.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> TessErrorCode.IMAGE_PATH_IS_NULL;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取Bitmap</span></span><br><span class="line">       BitmapFactory.<span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapFactory</span>.Options();</span><br><span class="line">       options.inSampleSize = <span class="number">2</span>;</span><br><span class="line">       <span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> BitmapFactory.decodeFile(imagePath, options);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 图片旋转角度</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">rotate</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">ExifInterface</span> <span class="variable">exif</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExifInterface</span>(imagePath);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 先获取当前图像的方向，判断是否需要旋转</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">imageOrientation</span> <span class="operator">=</span> exif</span><br><span class="line">               .getAttributeInt(ExifInterface.TAG_ORIENTATION,</span><br><span class="line">                       ExifInterface.ORIENTATION_NORMAL);</span><br><span class="line"></span><br><span class="line">       Log.i(TAG, <span class="string">&quot;Current image orientation is &quot;</span> + imageOrientation);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">switch</span> (imageOrientation) &#123;</span><br><span class="line">           <span class="keyword">case</span> ExifInterface.ORIENTATION_ROTATE_90:</span><br><span class="line">               rotate = <span class="number">90</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> ExifInterface.ORIENTATION_ROTATE_180:</span><br><span class="line">               rotate = <span class="number">180</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> ExifInterface.ORIENTATION_ROTATE_270:</span><br><span class="line">               rotate = <span class="number">270</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Log.i(TAG, <span class="string">&quot;Current image need rotate: &quot;</span> + rotate);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取当前图片的宽和高</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> bitmap.getWidth();</span><br><span class="line">       <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> bitmap.getHeight();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 使用Matrix对图片进行处理</span></span><br><span class="line">       <span class="type">Matrix</span> <span class="variable">mtx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Matrix</span>();</span><br><span class="line">       mtx.preRotate(rotate);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 旋转图片</span></span><br><span class="line">       bitmap = Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, w, h, mtx, <span class="literal">false</span>);</span><br><span class="line">       bitmap = bitmap.copy(Bitmap.Config.ARGB_8888, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 开始调用Tess函数对图像进行识别</span></span><br><span class="line">       <span class="type">TessBaseAPI</span> <span class="variable">baseApi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TessBaseAPI</span>();</span><br><span class="line">       baseApi.setDebug(<span class="literal">true</span>);</span><br><span class="line">       <span class="comment">// 使用默认语言初始化BaseApi</span></span><br><span class="line">       baseApi.init(TessConstantConfig.TESSBASE_PATH,</span><br><span class="line">               TessConstantConfig.DEFAULT_LANGUAGE_CHI);</span><br><span class="line">       baseApi.setImage(bitmap);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取返回值</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">recognizedText</span> <span class="operator">=</span> baseApi.getUTF8Text();</span><br><span class="line">       baseApi.end();</span><br><span class="line">       <span class="keyword">return</span> recognizedText;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>使用之前，需要先下载数据包到&#x2F;mnt&#x2F;sdcard&#x2F;tesseract&#x2F;目录下，下载地址在上边文章中已经有提到。可以根据需要识别的语言进行下载</p><p><a href="https://github.com/tesseract-ocr/tessdata">数据包下载地址</a></p><p>经过测试，发现tess-two的识别率不是很高，对一般电脑输入文字生成的图片，识别度较高，但对于手写问题，识别率较低，可能需要进一步进行训练。下边是我识别的结果截图：</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>总结tess-two的使用方法，大致可分为以下几步：</p><ol><li>下载并解压tess-two，下载路径：</li><li>编译，获得.so文件，或者直接下载我编译好的tess-two文件，可以不用下载tess-two源码</li><li>测试，训练</li></ol>]]></content>
    
    
    <summary type="html">Android集成OCR实现文字识别</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
    <category term="OCR" scheme="http://example.com/tags/OCR/"/>
    
    <category term="图像识别" scheme="http://example.com/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>Android平台OCR工具之Tess-two使用</title>
    <link href="http://example.com/2016/02/25/20160225Android%E5%B9%B3%E5%8F%B0OCR%E5%B7%A5%E5%85%B7%E4%B9%8BTess-two%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2016/02/25/20160225Android%E5%B9%B3%E5%8F%B0OCR%E5%B7%A5%E5%85%B7%E4%B9%8BTess-two%E4%BD%BF%E7%94%A8/</id>
    <published>2016-02-25T08:27:08.000Z</published>
    <updated>2020-12-09T06:29:20.130Z</updated>
    
    <content type="html"><![CDATA[<p>OCR （Optical Character Recognition，光学字符识别）是指电子设备（例如扫描仪或数码相机）检查纸上打印的字符，通过检测暗、亮的模式确定其形状，然后用字符识别方法将形状翻译成计算机文字的过程；</p><h3 id="1-Tesseract简介"><a href="#1-Tesseract简介" class="headerlink" title="1. Tesseract简介"></a>1. Tesseract简介</h3><p>Tesseract是Ray Smith于1985到1995年间在惠普布里斯托实验室开发的一个OCR引擎，曾经在1995 UNLV精确度测试中名列前茅。但1996年后基本停止了开发。2006年，Google邀请Smith加盟，重启该项目。目前项目的许可证是Apache 2.0。该项目目前支持Windows、Linux和Mac OS等主流平台。但作为一个引擎，它只提供命令行工具。<br>现阶段的Tesseract由Google负责维护，是最好的开源OCR Engine之一，并且支持中文。</p><span id="more"></span><p>主页地址：<a href="https://github.com/tesseract-ocr">https://github.com/tesseract-ocr</a></p><p>在Tesseract的主页中，我们可以下载到Tesseract的源码及语言包，常用的语言包为</p><p>中文：<a href="https://github.com/tesseract-ocr/tessdata">chi-sim.traineddata</a></p><p>英文：<a href="https://github.com/tesseract-ocr/tessdata">eng.traineddata</a></p><h3 id="2-Tess-two"><a href="#2-Tess-two" class="headerlink" title="2. Tess-two"></a>2. Tess-two</h3><p>因为Tesseract使用C++实现的，在Android中不能直接使用，需要封装JavaAPI才能在Android平台中进行调用，这里我们直接使用TessTwo项目，tess-two是TesseraToolsForAndroid的一个git分支，使用简单，切集成了leptonica，在使用之前需要先从git上下载源码进行编译。</p><h4 id="2-1-项目地址"><a href="#2-1-项目地址" class="headerlink" title="2.1 项目地址"></a>2.1 项目地址</h4><p>Tess-two在git上地址为：<a href="https://github.com/rmtheis/tess-two">https://github.com/rmtheis/tess-two</a></p><h4 id="2-2-编译"><a href="#2-2-编译" class="headerlink" title="2.2 编译"></a>2.2 编译</h4><p>我编译使用的环境：</p><ul><li>Eclipse 4.2.1</li><li>ADT 23.0.2</li><li>NDK R10</li><li>Cygwin</li></ul><p>NDK环境的具体配置及Cygwin的安装方法可以参照这篇博客：<a href="http://blog.csdn.net/pengchua/article/details/7582949">Windows下Android NDK环境搭建</a></p><p>配置好NDK环境后，将从git上下载的Tess-two进行解压，放置的路径是： E:\CooGame\OCR\TessTwo源码，下边开始进行编译：</p><ul><li>第一步：在Cygwin软件中使用cd命令打开Tesstwo的根目录。</li><li>第二步：切换到tess-two目录下的jni目录</li><li>第三步：输入命令进行编译</li></ul><p><img src="http://image.jucaiwy.com/image/20160225/tess_two_1.png"></p><p>编译需要耗费挺长时间，编译完成后，会在tess-two目录下生成libs文件夹，其中包含了编译生成的.so文件，可以进行使用。</p><p>也可以直接下载我编译好的包，这里给出下载地址，我测试了一下，是没有问题的。</p><p><a href="http://download.csdn.net/detail/duanbokan/9443521">tess-two下载</a></p><h3 id="3-tess-two使用"><a href="#3-tess-two使用" class="headerlink" title="3. tess-two使用"></a>3. tess-two使用</h3><p>编译完成后，新建工程，将之前编译好的libs文件夹下的armeabi和armeabi-v7a文件夹拷贝至新建工程的libs文件夹下，将tess-two工程中src文件夹下的两个包直接拷贝至代码中或者打成jar进行使用。工程如下：</p><p><img src="http://image.jucaiwy.com/image/20160225/tess_two_2.png"></p><p>识别函数：</p><pre><code>/** * 识别图片中文字,需要放入异步线程中进行执行 *  * @param bitmap * @return * @throws IOException */public String parseImageToString(String imagePath) throws IOException&#123;    // 检验图片地址是否正确    if (imagePath == null || imagePath.equals(&quot;&quot;))    &#123;        return TessErrorCode.IMAGE_PATH_IS_NULL;    &#125;    // 获取Bitmap    BitmapFactory.Options options = new BitmapFactory.Options();    options.inSampleSize = 2;    Bitmap bitmap = BitmapFactory.decodeFile(imagePath, options);    // 图片旋转角度    int rotate = 0;    ExifInterface exif = new ExifInterface(imagePath);    // 先获取当前图像的方向，判断是否需要旋转    int imageOrientation = exif            .getAttributeInt(ExifInterface.TAG_ORIENTATION,                    ExifInterface.ORIENTATION_NORMAL);    Log.i(TAG, &quot;Current image orientation is &quot; + imageOrientation);    switch (imageOrientation)    &#123;        case ExifInterface.ORIENTATION_ROTATE_90:            rotate = 90;            break;        case ExifInterface.ORIENTATION_ROTATE_180:            rotate = 180;            break;        case ExifInterface.ORIENTATION_ROTATE_270:            rotate = 270;            break;        default:            break;    &#125;    Log.i(TAG, &quot;Current image need rotate: &quot; + rotate);    // 获取当前图片的宽和高    int w = bitmap.getWidth();    int h = bitmap.getHeight();    // 使用Matrix对图片进行处理    Matrix mtx = new Matrix();    mtx.preRotate(rotate);    // 旋转图片    bitmap = Bitmap.createBitmap(bitmap, 0, 0, w, h, mtx, false);    bitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);    // 开始调用Tess函数对图像进行识别    TessBaseAPI baseApi = new TessBaseAPI();    baseApi.setDebug(true);    // 使用默认语言初始化BaseApi    baseApi.init(TessConstantConfig.TESSBASE_PATH,            TessConstantConfig.DEFAULT_LANGUAGE_CHI);    baseApi.setImage(bitmap);    // 获取返回值    String recognizedText = baseApi.getUTF8Text();    baseApi.end();    return recognizedText;&#125;</code></pre><p>使用之前，需要先下载数据包到&#x2F;mnt&#x2F;sdcard&#x2F;tesseract&#x2F;目录下，下载地址在上边文章中已经有提到。可以根据需要识别的语言进行下载</p><p><a href="https://github.com/tesseract-ocr/tessdata">数据包下载地址</a></p><p>经过测试，发现tess-two的识别率不是很高，对一般电脑输入文字生成的图片，识别度较高，但对于手写问题，识别率较低，可能需要进一步进行训练。下边是我识别的结果截图：</p><p><img src="http://image.jucaiwy.com/image/20160225/tess_two_3.png"></p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>总结tess-two的使用方法，大致可分为以下几步：</p><pre><code>1. 下载并解压tess-two2. 编译，获得.so文件，或者直接下载我编译好的tess-two文件，可以不用下载tess-two源码3. 新建工程测试，训练</code></pre><h3 id="5-代码"><a href="#5-代码" class="headerlink" title="5. 代码"></a>5. 代码</h3><p><a href="http://download.csdn.net/detail/duanbokan/9443595">我是代码</a></p>]]></content>
    
    
    <summary type="html">Android下使用Protobuf进行序列化</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
    <category term="OCR" scheme="http://example.com/tags/OCR/"/>
    
    <category term="Tess-Two" scheme="http://example.com/tags/Tess-Two/"/>
    
    <category term="Tesseract" scheme="http://example.com/tags/Tesseract/"/>
    
  </entry>
  
  <entry>
    <title>EventBus简介及使用</title>
    <link href="http://example.com/2016/01/06/20160106EventBus%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2016/01/06/20160106EventBus%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8/</id>
    <published>2016-01-06T02:16:05.000Z</published>
    <updated>2020-12-09T06:28:42.590Z</updated>
    
    <content type="html"><![CDATA[<p>EventBus是一个Android下典型的“订阅发布模式”框架，该模式定义了一种一对多的依赖关系，让多个订阅者对象同时监听一个主题对象，通过这种方式对订阅者和主题发布者进行充分解耦，主要用于Android组件间相互通信、线程间互相通信及其他线程与UI线程之间互相通信等。代替了传统的Handler、BroadCastReceiver、Interface回调等通信方式，相比之下EventBus的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。</p><h3 id="1-项目地址"><a href="#1-项目地址" class="headerlink" title="1. 项目地址"></a>1. 项目地址</h3><p>EventBus开源项目的项目地址：<a href="https://github.com/greenrobot/EventBus">https://github.com/greenrobot/EventBus</a></p><h3 id="2-相关概念"><a href="#2-相关概念" class="headerlink" title="2. 相关概念"></a>2. 相关概念</h3><h4 id="2-1-事件："><a href="#2-1-事件：" class="headerlink" title="2.1 事件："></a>2.1 事件：</h4><p>我所理解的事件就是需要在订阅者和发布者之间进行传递的数据，可以为单个基本类型的值，也可以为一个自定义的对象。</p><p>事件可以分为一般事件和Sticky事件，相对于一般事件，Sticky事件不同之处在于：当事件发布后，再有订阅者开始订阅该类型事件，依然能收到该类型事件最近一个sticky事件，与StickyBroadcast类似。</p><p>事件可以在任意线程进行发布,EventBus会根据发布事件类型，调用相对应事件的处理函数进行处理。</p><h4 id="2-2-订阅者："><a href="#2-2-订阅者：" class="headerlink" title="2.2 订阅者："></a>2.2 订阅者：</h4><p>订阅者是订阅某种事件类型的对象，当发布者发布这类事件后，EventBus会执行订阅者中相对应的事件响应函数。</p><p>普通事件订阅者通过register接口订阅某个事件类型，unregister接口退订。<br>Sticky事件的订阅者通过registerSticky接口订阅某个事件类型，通过unregister接口退订。</p><p>订阅者存在优先级，优先级高的订阅者可以取消事件继续向优先级低的订阅者分发，默认所有订阅者优先级都为0。</p><h4 id="2-3-发布者："><a href="#2-3-发布者：" class="headerlink" title="2.3 发布者："></a>2.3 发布者：</h4><p>发布事件的对象。</p><p>对于普通事件，使用post接口发布事件</p><p>对于Sticky事件，则使用postSticky接口发布事件</p><h3 id="3-基本使用"><a href="#3-基本使用" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h3><p>以自定义对象为事件进行距离介绍</p><h4 id="3-1-自定义对象"><a href="#3-1-自定义对象" class="headerlink" title="3.1 自定义对象"></a>3.1 自定义对象</h4><p>定义传递事件的对象Message</p><pre><code>public class Message&#123;    // 消息号    private int messageCode;    // 消息内容    private int messageInfo;&#125;</code></pre><h4 id="3-2-注册监听者"><a href="#3-2-注册监听者" class="headerlink" title="3.2 注册监听者"></a>3.2 注册监听者</h4><p>注册当前对象为监听者</p><pre><code>EventBus.getDefault().register(this);</code></pre><p>或者</p><pre><code>EventBus.getDefault().register(EventBusMsgDeal.class);</code></pre><p>对于监听Sticky事件：</p><pre><code>EventBus.getDefault().registerSticky(this);</code></pre><h4 id="3-3-发布事件"><a href="#3-3-发布事件" class="headerlink" title="3.3 发布事件"></a>3.3 发布事件</h4><p>发布事件时，分为两种事件进行发布 </p><p>普通事件：</p><pre><code>EventBus.getDefault().post(msg);</code></pre><p>Sticky事件：</p><pre><code>EventBus.getDefault().postSticky(msg);</code></pre><h4 id="3-4-解除监听"><a href="#3-4-解除监听" class="headerlink" title="3.4 解除监听"></a>3.4 解除监听</h4><pre><code>EventBus.getDefault().unregister(this);</code></pre><p>这里特别需要注意这个东西，一般在Activity声明周期结束的时候，需要调用这个方法将监听解除，否则，不仅影响性能，还会出现很多问题</p><h4 id="3-5-事件处理"><a href="#3-5-事件处理" class="headerlink" title="3.5 事件处理"></a>3.5 事件处理</h4><p>对于事件处理，可以按照普通事件和Sticky事件进行区分，对于普通事件，可以分为以下四种处理方式：</p><h5 id="3-5-1-OnEvent"><a href="#3-5-1-OnEvent" class="headerlink" title="3.5.1 OnEvent():"></a>3.5.1 OnEvent():</h5><p>使用OnEvent作为订阅处理函数，则表示发布事件和接受处理事件将会在同一个线程中执行，因此在该方法中，不宜执行一些耗时的操作，否则会造成阻塞、延迟。</p><h5 id="3-5-2-onEventMainThread"><a href="#3-5-2-onEventMainThread" class="headerlink" title="3.5.2 onEventMainThread():"></a>3.5.2 onEventMainThread():</h5><p>使用onEventMainThread作为订阅处理函数，表示事件无论是在哪一个线程中发布出来的，都会在UI线程中执行，意味着可以再该线程中更新UI，因此在该线程中同样不适宜执行一些比较耗时的操作，否则会造成UI线程阻塞，进而导致NAR。</p><h5 id="3-5-3-onEventBackgroundThread"><a href="#3-5-3-onEventBackgroundThread" class="headerlink" title="3.5.3 onEventBackgroundThread():"></a>3.5.3 onEventBackgroundThread():</h5><p>使用onEventBackgroundThread作为订阅处理函数，恰好与onEventMainThread相反，onEventMainThread是无论在哪一个线程中发送事件，都会在UI线程中执行。而onEventBackgroundThread意味着，无论在哪一个线程中发送事件，都会在子线程中执行，也就是说，若当前Post线程为UI线程，则处理函数会在子线程中执行，若当前Post线程为子线程，则直接在该线程中执行。</p><h5 id="3-5-4-onEventAsync"><a href="#3-5-4-onEventAsync" class="headerlink" title="3.5.4 onEventAsync():"></a>3.5.4 onEventAsync():</h5><p>使用onEventAsync作为订阅处理函数，意味着，无论当前在哪一个线程中Post事件出来，都会新起一个线程进行执行。</p><h3 id="4-执行顺序"><a href="#4-执行顺序" class="headerlink" title="4. 执行顺序"></a>4. 执行顺序</h3><p>写到这里，可能有同学会迷惑，这四个方法如果同时出现在同一个类中，执行的先后顺序应该是什么样子的，这里我做了一个测试，得到其调用顺序如下：</p><pre><code>1. onEvent();2. onEventMainThread();3. onEventAsync();4. onEventBackgroundThread();</code></pre><h3 id="5-结束"><a href="#5-结束" class="headerlink" title="5. 结束"></a>5. 结束</h3><p>至此，已经大致学会了使用EventBus的使用，如果需要学习更多关于EventBus的源码解析及设计思想，可以参考以下链接：</p><p>源码解析：<a href="http://www.codekk.com/">http://www.codekk.com/</a></p><p>设计思想：<a href="http://www.cnblogs.com/MartinChen999/archive/2011/12/21/2294034.html">http://www.cnblogs.com/MartinChen999/archive/2011/12/21/2294034.html</a></p><p>同样和EventBus具有相似功能的还有：Otto</p><p>项目地址：<a href="https://github.com/square/otto">https://github.com/square/otto</a></p><p>主页：<a href="http://square.github.io/otto/">http://square.github.io/otto/</a></p>]]></content>
    
    
    <summary type="html">EventBus简介及使用</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
    <category term="EventBus" scheme="http://example.com/tags/EventBus/"/>
    
    <category term="观察者模式" scheme="http://example.com/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android横竖屏切换时生命周期变化</title>
    <link href="http://example.com/2015/12/18/20151218Android_%E6%A8%AA%E7%AB%96%E5%B1%8F%E5%88%87%E6%8D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://example.com/2015/12/18/20151218Android_%E6%A8%AA%E7%AB%96%E5%B1%8F%E5%88%87%E6%8D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2015-12-17T16:00:00.000Z</published>
    <updated>2020-12-09T06:28:22.520Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中我们经常会遇到横竖屏切换的场景，那么在这些场景下，Activity的生命周期是一个怎么样的调用呢，本文中我们打印日志记录了一个Activity横竖屏切换时的生命周期的调用，方便以后开发过程中的查阅和记忆。</p><h3 id="1-设置横屏"><a href="#1-设置横屏" class="headerlink" title="1. 设置横屏"></a>1. 设置横屏</h3><p>在AndroidManifest.xml文件中对应的Activity加上如下标签:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:screenOrientation=<span class="string">&quot;landscape&quot;</span></span><br></pre></td></tr></table></figure><p>该Activity将会设置为横屏。</p><h3 id="2-横屏旋转时生命周期"><a href="#2-横屏旋转时生命周期" class="headerlink" title="2. 横屏旋转时生命周期"></a>2. 横屏旋转时生命周期</h3><p>横屏竖屏切换时，系统会走该应用所有生命周期</p><p><img src="http://image.jucaiwy.com/image/20151218/ConfigurationChanged1.png"></p><p>这里需要注意，横屏切换竖屏时，会执行一次OnCreat和两次OnRestart。</p><p><img src="http://image.jucaiwy.com/image/20151218/ConfigurationChanged2.png"></p><p>竖屏切换横屏时，会执行一次OnRestart和一次OnCreat。</p><h3 id="3-设置横竖屏切换时，不执行生命周期"><a href="#3-设置横竖屏切换时，不执行生命周期" class="headerlink" title="3. 设置横竖屏切换时，不执行生命周期"></a>3. 设置横竖屏切换时，不执行生命周期</h3><p>在AndroidManifest.xml文件中对应的Activity加上如下标签:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:configChanges=<span class="string">&quot;orientation|keyboardHidden|screenSize&quot;</span></span><br></pre></td></tr></table></figure><p>切记一定要加上后边的screenSize否则在4.0以上版本不生效。</p><p>加上后，再次进行切换，则不会重复执行生命周期，只是执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">&quot;监听到横竖屏切换&quot;</span>);</span><br><span class="line">    <span class="built_in">super</span>.onConfigurationChanged(newConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上后执行过程如下：</p><p><img src="http://image.jucaiwy.com/image/20151218/ConfigurationChanged3.png"></p><p>需要注意的是，折叠屏适配许多工作都在<strong>onConfigurationChanged</strong>中完成</p>]]></content>
    
    
    <summary type="html">Android横竖屏切换生命周期</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="Android笔记" scheme="http://example.com/tags/Android%E7%AC%94%E8%AE%B0/"/>
    
    <category term="横竖屏切换" scheme="http://example.com/tags/%E6%A8%AA%E7%AB%96%E5%B1%8F%E5%88%87%E6%8D%A2/"/>
    
    <category term="生命周期" scheme="http://example.com/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Android使用SQLite批量入库操作性能对比</title>
    <link href="http://example.com/2015/10/16/20151016Android%E4%BD%BF%E7%94%A8SQLite%E6%89%B9%E9%87%8F%E5%85%A5%E5%BA%93%E6%93%8D%E4%BD%9C%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"/>
    <id>http://example.com/2015/10/16/20151016Android%E4%BD%BF%E7%94%A8SQLite%E6%89%B9%E9%87%8F%E5%85%A5%E5%BA%93%E6%93%8D%E4%BD%9C%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/</id>
    <published>2015-10-16T06:28:28.000Z</published>
    <updated>2020-12-09T06:27:46.170Z</updated>
    
    <content type="html"><![CDATA[<p>Android开发过程中经常会用到数据库，不可避免的会出现批量操作数据库，比如一次操作需要往数据库中插入一万条记录，这就需要进行批量操作，以下提供了四种批量操作方式，并分别进行对比。</p><ul><li>直接使用SQL语句进行插入</li><li>直接使用SQL语句插入，添加事务</li><li>使用ContentValues方式</li><li>使用SQLiteStatement方式</li></ul><p>接下来对每一种方式的实现及性能分别进行对比（向统一数据库同一张表插入一万条数据）：</p><h3 id="1-直接使用SQL语句进行插入"><a href="#1-直接使用SQL语句进行插入" class="headerlink" title="1. 直接使用SQL语句进行插入"></a>1. 直接使用SQL语句进行插入</h3><p>实现代码：</p><pre><code>@Overridepublic CommonResult addGroupMember()&#123;    String insertSQL = &quot;insert into &quot;            + SQLHelp.GROUP_MEMBER_TABLENAME            + &quot;(&quot;            + SQLHelp.GROUP_ID            + &quot;,&quot;            + SQLHelp.MEMBERS_SUBS_ID            + &quot;,&quot;            + SQLHelp.MEMBER_NICK_NAME            + &quot;,&quot;            + SQLHelp.MEMBER_ROLE            + &quot;,&quot;            + SQLHelp.MEMBER_JID            + &quot;,&quot;            + SQLHelp.MEM_UNION_KEY            + &quot;,&quot;            + SQLHelp.CREAT_TIME            + &quot;, &quot;            + SQLHelp.UPDATE_TIME            + &quot;,&quot;            + SQLHelp.ORDER_ID            + &quot;,&quot;            + SQLHelp.EXT            + &quot; ) values(458906628,85469875,&#39;xinwei&#39;,2,100856,18663,&#39;2015-06-08&#39;,&#39;2015-06-09&#39;,123456,&#39;beizhu&#39;)&quot;;    SQLiteDatabase sqlDatabase = sqlHelp.getWritableDatabase();    // 插入一万条    for (int i = 0; i &lt; 10000; i++)    &#123;        sqlDatabase.execSQL(insertSQL);    &#125;    return null;&#125;</code></pre><p>计时结果如下： </p><p><img src="http://image.jucaiwy.com/image/20151016/20151016135641277.png"></p><h3 id="2-直接使用SQL语句插入，添加事务"><a href="#2-直接使用SQL语句插入，添加事务" class="headerlink" title="2. 直接使用SQL语句插入，添加事务"></a>2. 直接使用SQL语句插入，添加事务</h3><p>这种方法是在第一种方法的基础上，添加事务操作：</p><pre><code>// 开始sqlDatabase.beginTransaction();// 设置为成功sqlDatabase.setTransactionSuccessful();// 结束sqlDatabase.endTransaction();</code></pre><p>在操作数据库之前设置为开始、数据库语句执行完毕后，设置数据库事务为Success，当执行到sqlDatabase.endTransaction()时，系统会判断之前是否有设置成功标志，如果没有则认为插入失败，数据库自动进行回滚操作。</p><p>执行代码如下：</p><pre><code>@Overridepublic CommonResult addGroupMemberThing()&#123;    String insertSQL = &quot;insert into &quot;            + SQLHelp.GROUP_MEMBER_TABLENAME            + &quot;(&quot;            + SQLHelp.GROUP_ID            + &quot;,&quot;            + SQLHelp.MEMBERS_SUBS_ID            + &quot;,&quot;            + SQLHelp.MEMBER_NICK_NAME            + &quot;,&quot;            + SQLHelp.MEMBER_ROLE            + &quot;,&quot;            + SQLHelp.MEMBER_JID            + &quot;,&quot;            + SQLHelp.MEM_UNION_KEY            + &quot;,&quot;            + SQLHelp.CREAT_TIME            + &quot;, &quot;            + SQLHelp.UPDATE_TIME            + &quot;,&quot;            + SQLHelp.ORDER_ID            + &quot;,&quot;            + SQLHelp.EXT            + &quot; ) values(458906628,85469875,&#39;xinwei&#39;,2,100856,18663,&#39;2015-06-08&#39;,&#39;2015-06-09&#39;,123456,&#39;beizhu&#39;)&quot;;    SQLiteDatabase sqlDatabase = sqlHelp.getWritableDatabase();    // 开始    sqlDatabase.beginTransaction();    // 循环一万次    for (int i = 0; i &lt; 10000; i++)    &#123;        // 执行语句        sqlDatabase.execSQL(insertSQL);    &#125;    // 成功    sqlDatabase.setTransactionSuccessful();    // 结束    sqlDatabase.endTransaction();    return null;&#125;</code></pre><p>执行结束后，结果如下：</p><p><img src="http://image.jucaiwy.com/image/20151016/20151016141825629.png"></p><h3 id="3-使用ContentValues方式"><a href="#3-使用ContentValues方式" class="headerlink" title="3. 使用ContentValues方式"></a>3. 使用ContentValues方式</h3><p>使用ContentValues的好处是可以动态拼接SQL语句进行执行，有更好的灵活性，可以直接使用对象进行赋值，代码如下：</p><pre><code>@Overridepublic CommonResult addGroupMemberContentValues(CamTalkGroupMemberInfo memberInfo)&#123;    SQLiteDatabase sqlDatabase = sqlHelp.getWritableDatabase();    try    &#123;        sqlDatabase.beginTransaction();        ContentValues values = new ContentValues();        if (memberInfo != null)        &#123;            values.put(SQLHelp.GROUP_ID, memberInfo.getGroupID());            values.put(SQLHelp.MEMBERS_SUBS_ID, memberInfo.getMemberSubsID());            values.put(SQLHelp.MEMBER_NICK_NAME, memberInfo.getMemberNickName());            values.put(SQLHelp.MEMBER_ROLE, memberInfo.getMemberRole());            values.put(SQLHelp.MEMBER_JID, memberInfo.getMemberJID());            values.put(SQLHelp.MEM_UNION_KEY, memberInfo.getMemUnionKey());            values.put(SQLHelp.CREAT_TIME, convertDate2String(memberInfo.getCreatTime()));            values.put(SQLHelp.UPDATE_TIME, convertDate2String(memberInfo.getUpdateTime()));            values.put(SQLHelp.ORDER_ID, memberInfo.getOrderID());            values.put(SQLHelp.EXT, memberInfo.getExt());            // 插入10000次            for (int i = 0; i &lt; 10000; i++)            &#123;                sqlDatabase.insert(SQLHelp.GROUP_MEMBER_TABLENAME, null, values);            &#125;        &#125;        // 成功        sqlDatabase.setTransactionSuccessful();    &#125;    catch (Exception e)    &#123;        e.printStackTrace();    &#125;    finally    &#123;        // 结束        sqlDatabase.endTransaction();        sqlDatabase.close();    &#125;    return null;&#125;</code></pre><p>执行完毕后，结果如下：</p><p><img src="http://image.jucaiwy.com/image/20151016/20151016142239726.png"></p><h3 id="4-使用SQLiteStatement方式"><a href="#4-使用SQLiteStatement方式" class="headerlink" title="4. 使用SQLiteStatement方式"></a>4. 使用SQLiteStatement方式</h3><p>这个方法与上边ContentValues方式实现大致类似，不同的是需要自己编写SQL语句：</p><pre><code>@Overridepublic CommonResult addGroupMemberStatement(CamTalkGroupMemberInfo memberInfo)&#123;    SQLiteDatabase sqlDatabase = null;    String insertSQL = &quot;insert into &quot; + SQLHelp.GROUP_MEMBER_TABLENAME + &quot;(&quot; + SQLHelp.GROUP_ID            + &quot;,&quot; + SQLHelp.MEMBERS_SUBS_ID + &quot;,&quot; + SQLHelp.MEMBER_NICK_NAME + &quot;,&quot;            + SQLHelp.MEMBER_ROLE + &quot;,&quot; + SQLHelp.MEMBER_JID + &quot;,&quot; + SQLHelp.MEM_UNION_KEY            + &quot;,&quot; + SQLHelp.CREAT_TIME + &quot;, &quot; + SQLHelp.UPDATE_TIME + &quot;,&quot; + SQLHelp.ORDER_ID            + &quot;,&quot; + SQLHelp.EXT + &quot;) values &quot; + &quot;(?,?,?,?,?,?,?,?,?,?)&quot;;    try    &#123;        sqlDatabase = sqlHelp.getWritableDatabase();        // SQL事物控制-结束之前检测是否成功，没有成功则自动回滚        sqlDatabase.beginTransaction();        SQLiteStatement stat = sqlDatabase.compileStatement(insertSQL);        stat.bindLong(1, memberInfo.getGroupID());        stat.bindString(2, memberInfo.getMemberSubsID());        stat.bindString(3, memberInfo.getMemberNickName());        stat.bindLong(4, memberInfo.getMemberRole());        stat.bindString(5, memberInfo.getMemberJID());        stat.bindString(6, memberInfo.getMemUnionKey());        stat.bindString(7, convertDate2String(memberInfo.getCreatTime()));        stat.bindString(8, convertDate2String(memberInfo.getUpdateTime()));        stat.bindString(9, memberInfo.getOrderID());        stat.bindString(10, memberInfo.getExt());        // 插入10000次        for (int i = 0; i &lt; 10000; i++)        &#123;            stat.executeInsert();        &#125;        // 成功        sqlDatabase.setTransactionSuccessful();    &#125;    catch (SQLException e)    &#123;        e.printStackTrace();    &#125;    finally    &#123;        // 结束        sqlDatabase.endTransaction();        sqlDatabase.close();    &#125;    return null;&#125;</code></pre><p>执行结果如下： </p><p><img src="http://image.jucaiwy.com/image/20151016/20151016142545977.png"></p><h3 id="5-总的对比图"><a href="#5-总的对比图" class="headerlink" title="5. 总的对比图"></a>5. 总的对比图</h3><p><img src="http://image.jucaiwy.com/image/20151016/sqlite.png"></p><p>综上，对比四种结果，使用SQLiteStatement 插入最快，插入一万条数据，只需三秒钟，性能最好。</p>]]></content>
    
    
    <summary type="html">Android使用SQLite批量入库操作性能对比</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
    <category term="SQLite数据库" scheme="http://example.com/tags/SQLite%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="数据库性能" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
</feed>
