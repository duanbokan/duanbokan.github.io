<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Flutter状态管理 | 沙僧</title><meta name="keywords" content="Flutter,状态管理,Provider"><meta name="author" content="沙僧"><meta name="copyright" content="沙僧"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Flutter—状态管理机制">
<meta property="og:type" content="article">
<meta property="og:title" content="Flutter状态管理">
<meta property="og:url" content="http://example.com/2022/04/19/Flutter%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="沙僧">
<meta property="og:description" content="Flutter—状态管理机制">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://image.jucaiwy.com/image/20220419/flutter_state_cover.jpeg">
<meta property="article:published_time" content="2022-04-19T06:54:46.000Z">
<meta property="article:modified_time" content="2022-04-19T07:16:47.224Z">
<meta property="article:author" content="沙僧">
<meta property="article:tag" content="Flutter">
<meta property="article:tag" content="状态管理">
<meta property="article:tag" content="Provider">
<meta property="article:tag" content="Stream">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://image.jucaiwy.com/image/20220419/flutter_state_cover.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/04/19/Flutter%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Flutter状态管理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-19 15:16:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="沙僧" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="http://image.jucaiwy.com/favicon.ico" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://image.jucaiwy.com/image/20220419/flutter_state_cover.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">沙僧</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Flutter状态管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-19T06:54:46.000Z" title="发表于 2022-04-19 14:54:46">2022-04-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-19T07:16:47.224Z" title="更新于 2022-04-19 15:16:47">2022-04-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Flutter/">Flutter</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Flutter状态管理"><a href="#Flutter状态管理" class="headerlink" title="Flutter状态管理"></a>Flutter状态管理</h2><p>在响应式编程中，状态即数据，状态变化，页面即发生变化，Flutter作为响应式开发框架，状态管理是Flutter开发过程中代码架构的重点，本文中，我们将通过分析常用的Flutter状态管理框架，给大家深入解析状态管理的核心实现方法，方便大家在后续开发中，挑选合适的状态管理框架。</p>
<p>Flutter本身已经给我们提供了一个状态管理方式，即Flutter自带的StatefulWidget，但是我们在应用过程中，会发现，这个状态仅仅适合在单个StatefulWidget中进行维护，当我们需要一个跨组件状态时，StatefulWidget将不再是一个好的选择，虽然我们可以使用callBack进行解决，但这个方式一旦业务增长到一定程度，嵌套较深的时候，将会造成很大的代码耦合，因此，我们需要使用一个状态管理组件进行维护这些状态。</p>
<p>常用的状态管理组件，包含了ScopedModel，BLoC，RxDart，Provider等，今天我们将在这里对这些状态管理机制的使用方法及原理进行剖析。</p>
<h3 id="一、-状态管理分类："><a href="#一、-状态管理分类：" class="headerlink" title="一、 状态管理分类："></a>一、 状态管理分类：</h3><p>首先，常用的状态管理，按照范围可以划分为局部状态管理和全局状态管理：</p>
<h4 id="局部状态："><a href="#局部状态：" class="headerlink" title="局部状态："></a>局部状态：</h4><p>Flutter提供了类似StatefulWidget、InheritWidget组件来实现局部状态管理，当这些Widget发生变化时，所有子树中依赖其数据的widget都会进行rebuild。</p>
<h4 id="全局状态："><a href="#全局状态：" class="headerlink" title="全局状态："></a>全局状态：</h4><p>Flutter没有提供原生的全局状态管理机制，虽然可以在根布局控件使用InheritWidget来实现全局状态管理，但是这样会存在类似依赖传递过深等问题。因此大多数情况下，需要依赖一些第三方库实现全局状态管理</p>
<h4 id="最简单的状态管理"><a href="#最简单的状态管理" class="headerlink" title="最简单的状态管理"></a>最简单的状态管理</h4><p>我们可以使用 State + InheritedWidget实现最简单的状态管理机制。</p>
<h3 id="二、-状态管理——Stream"><a href="#二、-状态管理——Stream" class="headerlink" title="二、 状态管理——Stream"></a>二、 状态管理——Stream</h3><p>Stream在Flutter中标志着的事件流或者管道一类的概念，通过Stream可以快速的实现给予事件流驱动的业务逻辑。界面通过订阅事件，并针对各个事件进行变化处理，实现响应式更新界面。 </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">展示文本</span></span></span><br><span class="line"><span class="built_in">String</span> textString = <span class="string">&quot;等待接收文本&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">单订阅Stream</span></span></span><br><span class="line">Stream&lt;<span class="built_in">String</span>&gt; stream = <span class="keyword">new</span> Stream.fromFuture(_doFutureTask());</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> initState() &#123;</span><br><span class="line">StreamSubscription subscription = stream.listen((data) &#123;</span><br><span class="line">  textString = data;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;接收数据成功&quot;</span>);</span><br><span class="line">&#125;, onDone: () &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;流处理完成&quot;</span>);</span><br><span class="line">&#125;, onError: () &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;流处理出现异常&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Subscription<span class="emphasis">_API</span></span></span></span><br><span class="line">subscription.cancel();</span><br><span class="line">subscription.pause();</span><br><span class="line">subscription.resume();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="emphasis">异步任务</span></span></span></span><br><span class="line"><span class="keyword">static</span> _doFutureTask() &#123;</span><br><span class="line">	<span class="keyword">return</span> Future.delayed(<span class="built_in">Duration</span>(seconds: <span class="number">5</span>), () &#123;</span><br><span class="line">  	<span class="built_in">print</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是一个最简单的，通过异步任务创建流对象的方法，包含了流的创建、监听、管理，Stream流，分为单订阅流和广播流</p>
<h4 id="单订阅流"><a href="#单订阅流" class="headerlink" title="单订阅流"></a>单订阅流</h4><p>单订阅流只允许在该Stream的整个生命周期，注册一个监听器，即使第一个监听器被取消了，也无法在这个时间流中，监听到第二次事件。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">StreamController&lt;<span class="built_in">String</span>&gt; singleStream = StreamController();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息发送</span></span><br><span class="line">singleStream.add(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用过程中，经常会在log平台输出： Bad state: Stream has already been listened to.<br>其含义就是指：单订阅流不能有多个收听者</p>
<h4 id="广播流"><a href="#广播流" class="headerlink" title="广播流"></a>广播流</h4><p>广播流，和单订阅流不同，允许任意个数的监听者，可以随时随地为其添加监听器，只要新的监听器，被添加进去，就可以收到新的事件</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">StreamController&lt;<span class="built_in">int</span>&gt; singleStream = StreamController.broadcast();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息发送</span></span><br><span class="line">singleStream.sink.add(<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>StreamController的构造函数是一个泛型，意味着StreamController可以往流上推送任意类型的数据，当然这里需要考虑接收时候的数据类型处理。</p>
<h4 id="StreamBuilder如何实现刷新"><a href="#StreamBuilder如何实现刷新" class="headerlink" title="StreamBuilder如何实现刷新"></a>StreamBuilder如何实现刷新</h4><p>在上边的例子中，我们看到了在页面中有使用一个StreamBuilder，来构建一个UI展示：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">StreamBuilder&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">        builder: (context, snapshot) &#123;</span><br><span class="line">          <span class="keyword">if</span> (snapshot == <span class="keyword">null</span> || !snapshot.hasData) &#123;</span><br><span class="line">            <span class="keyword">return</span> CircularProgressIndicator();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (snapshot.hasError) &#123;</span><br><span class="line">              <span class="keyword">return</span> Text(<span class="string">&quot;发生错误&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> Text(snapshot.data);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        stream: singleStream.stream,</span><br><span class="line">      )</span><br></pre></td></tr></table></figure>

<p>那么StreamBuilder和Widget的刷新，是怎么关联起来的呢？通过阅读代码，我们发现，其实StreamBuilder的主要逻辑在_StreamBuilderBaseState中，_StreamBuilderBaseState在initState、didUpdateWidget中会调用_subscribe方法，从而调用Stream的listen，然后通过setState更新UI。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _subscribe() &#123;</span><br><span class="line"><span class="keyword">if</span> (widget.stream != <span class="keyword">null</span>) &#123;</span><br><span class="line">  _subscription = widget.stream.listen((T data) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _summary = widget.afterData(_summary, data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, onError: (<span class="built_in">Object</span> error) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _summary = widget.afterError(_summary, error);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, onDone: () &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _summary = widget.afterDone(_summary);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  _summary = widget.afterConnected(_summary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  }</p>
<p>而setState的刷新机制，其实我们大家应该都知道，实质上是调用了markNeedsBuild，markNeedsBuild方法会标记element为dirty，这样在下一帧WidgetsBinding.drawFrame的时候，会进行绘制</p>
<h4 id="StreamController整体架构"><a href="#StreamController整体架构" class="headerlink" title="StreamController整体架构"></a>StreamController整体架构</h4><p>从上边几个demo中，我们看到Flutter的Stream流中，存在Stream、StreamController、Sink、以及StreamSubscription这样四个比较关键的组件，那么这四个组件是以一个什么样子的形式互相结合起来的呢。我们通过下边这样一副图，进行说明：</p>
<p><img src="http://image.jucaiwy.com/image/20220419/stream_pic.png"></p>
<p>整个流程，概括起来就是：StreamController作为一个统筹管理的“Boss”，主要负责协调和维护整个事件流的输入和输出，StreamController暴露了一个Sink属性，主要负责事件流的输入，在这里输入事件。暴露一个Stream属性，主要负责流事件的输出，除自身提供了事件转换方法，例如where、take等，主要进行事件流的转换。同时，Stream对外提供了事件的监听，分别可以处理在收到事件以后的处理onData，事件处理完成以后的onDone以及事件处理异常的onError等方法，通过注册这样的监听，我们又可以得到StreamSubscription这个属性，其功能，主要管理事件的订阅，包含取消、暂停、恢复等操作</p>
<h4 id="StreamController同步、异步处理"><a href="#StreamController同步、异步处理" class="headerlink" title="StreamController同步、异步处理"></a>StreamController同步、异步处理</h4><p>在初始化StreamController的时候，我们可以看到，有一个构造参数，sync，针对我们传递的sync值，决定使用同步流还是异步流。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">sync</span></span><br><span class="line">    ? <span class="keyword">new</span> _SyncStreamController&lt;T&gt;(onListen, onPause, onResume, onCancel)</span><br><span class="line">    : <span class="keyword">new</span> _AsyncStreamController&lt;T&gt;(onListen, onPause, onResume, onCancel);</span><br></pre></td></tr></table></figure>

<p>这里具体怎么实现的呢，我们一起来看一下。在同步流中，直接调用了subscription的_add方法，直接将数据添加进事件回掉监听中，实现同步：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _sendData(T data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_isEmpty) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (_hasOneListener) &#123;</span><br><span class="line">	      _state |= _BroadcastStreamController._STATE_FIRING;</span><br><span class="line">	      _BroadcastSubscription&lt;T&gt; subscription = _firstSubscription;</span><br><span class="line">	      subscription._add(data);</span><br><span class="line">	      _state &amp;= ~_BroadcastStreamController._STATE_FIRING;</span><br><span class="line">	      <span class="keyword">if</span> (_isEmpty) &#123;</span><br><span class="line">	        _callOnCancel();</span><br><span class="line">	      &#125;</span><br><span class="line">	      <span class="keyword">return</span>;		</span><br><span class="line">    &#125;</span><br><span class="line">    _forEachListener((_BufferingStreamSubscription&lt;T&gt; subscription) &#123;</span><br><span class="line">      	   subscription._add(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>​	<br>而在异步流中，则是使用_addPending方法，添加了一个继承自_DelayedEvent的方法，实现异步：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">_AsyncStreamControllerDispatch</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">_StreamController</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">void</span> _sendData(T data) &#123;</span><br><span class="line">		_subscription._addPending(<span class="keyword">new</span> _DelayedData&lt;T&gt;(data));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">void</span> _sendError(<span class="built_in">Object</span> error, StackTrace stackTrace) &#123;</span><br><span class="line">    	_subscription._addPending(<span class="keyword">new</span> _DelayedError(error, stackTrace));</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">void</span> _sendDone() &#123;</span><br><span class="line">    	_subscription._addPending(<span class="keyword">const</span> _DelayedDone());</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么Flutter是怎么实现异步的呢。我们继续深入挖掘，发现在异步任务中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> schedule(_EventDispatch&lt;T&gt; dispatch) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isScheduled) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">assert</span>(!isEmpty);</span><br><span class="line">    <span class="keyword">if</span> (_eventScheduled) &#123;</span><br><span class="line">      <span class="keyword">assert</span>(_state == _STATE_CANCELED);</span><br><span class="line">      _state = _STATE_SCHEDULED;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    scheduleMicrotask(() &#123;</span><br><span class="line">      <span class="built_in">int</span> oldState = _state;</span><br><span class="line">      _state = _STATE_UNSCHEDULED;</span><br><span class="line">      <span class="keyword">if</span> (oldState == _STATE_CANCELED) <span class="keyword">return</span>;</span><br><span class="line">      handleNext(dispatch);</span><br><span class="line">    &#125;);</span><br><span class="line">    _state = _STATE_SCHEDULED;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>因此，Flutter异步任务执行，实际上相当于在Microtask任务队列里边添加了一个任务，而我们都知道，Flutter为单线程应用，和大多数单线程应用一样，通过消息循环机制来运行，这个机制中，主要包含了两个任务队列，一个是microtask内部队列，一个是event外部队列，而microtask的优先级又高于event。Stream通过这样的方式实现了异步</p>
<p><img src="http://image.jucaiwy.com/image/20220419/flutter_thread.png"></p>
<p>至此，我们已经基本了解了Stream的原理及一些常用的api，这方便我们对后续的RxDart、Provider等进行分析</p>
<h3 id="三、状态管理——RxDart"><a href="#三、状态管理——RxDart" class="headerlink" title="三、状态管理——RxDart"></a>三、状态管理——RxDart</h3><p>说到RxDart就不得不提一下ReactiveX，<a target="_blank" rel="noopener" href="http://reactivex.io/">http://reactivex.io/</a>  </p>
<p>在其官网上，对ReactiveX的介绍为</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“An API <span class="keyword">for</span> asynchronous programming <span class="keyword">with</span> observable streams”</span><br></pre></td></tr></table></figure>

<p>用于可观察流的异步编程的API，一句话概括了ReactiveX的核心设计思想，为各个平台提供了异步编程的可观察流API。当然在Dart上也不例外。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">创建一个Subject</span></span></span><br><span class="line"><span class="keyword">var</span> subject = PublishSubject&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">通过listen实现订阅</span></span></span><br><span class="line">subject.listen((<span class="built_in">String</span> data) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;OnData &quot;</span> + data);</span><br><span class="line">&#125;, onError: () &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;onError &quot;</span>);</span><br><span class="line">&#125;, onDone: () &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;onDone &quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">使用完成，关闭</span></span></span><br><span class="line">subject.close();</span><br></pre></td></tr></table></figure>

<p>这里是一个最简单的RxDart的使用方法，细心的同学可能已经发现了，这不就是之前的StreamController么。的确是这样的，RxDart内部，其实也是对Stream的一个封装。PublishSubject的内部实现，其实也是一个广播类型的StreamController：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">factory</span> PublishSubject(&#123;<span class="keyword">void</span> onListen(), <span class="keyword">void</span> onCancel(), <span class="built_in">bool</span> <span class="keyword">sync</span> = <span class="keyword">false</span>&#125;) &#123;</span><br><span class="line">    <span class="comment">// ignore: close_sinks</span></span><br><span class="line">    <span class="keyword">final</span> controller = StreamController&lt;T&gt;.broadcast(</span><br><span class="line">      onListen: onListen,</span><br><span class="line">      onCancel: onCancel,</span><br><span class="line">      <span class="keyword">sync</span>: <span class="keyword">sync</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> PublishSubject&lt;T&gt;._(</span><br><span class="line">      controller,</span><br><span class="line">      Observable&lt;T&gt;(controller.stream),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>至此我们也明白了：</p>
<ol>
<li><p>在RxDart中Subject，无论是PublishSubject还是BehaviorSubject(只保留最后一个值的特殊流)，其核心其实还是StreamController</p>
</li>
<li><p>RxDart中的Observable实质上相当于一个Stream</p>
</li>
</ol>
<p>总结一下，RxDart，实际是对上边所说的Stream进行了概念转换，变成了ReactiveX用户熟悉的对象和操作符，本质上还是一个Stream，这也是为什么可以直接在StreamBuilder中使用RxDart。</p>
<h3 id="四、状态管理——Provider"><a href="#四、状态管理——Provider" class="headerlink" title="四、状态管理——Provider"></a>四、状态管理——Provider</h3><p>Provider是Flutter官方推荐的状态管理方式之一，它的特点是，不复杂，好理解，可控度较高。</p>
<h4 id="Provider使用"><a href="#Provider使用" class="headerlink" title="Provider使用"></a>Provider使用</h4><p>第一步	添加依赖</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">provider: ^<span class="number">2.0</span><span class="number">.1</span>+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>第二步  创建数据模型</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">计数module</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterModel</span> <span class="keyword">extends</span> <span class="title">ChangeNotifier</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">计数</span></span></span><br><span class="line">  <span class="built_in">int</span> _count = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> value =&gt; _count;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> increment() &#123;</span><br><span class="line">    _count++;</span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该Module继承自ChangeNotifier，主要负责数据模型保存和管理，同时暴露出来的notifyListeners()方法，在调用后，可以自动更新其所有的监听者。</p>
<p>第三步  创建全局共享数据依赖</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">数据模型</span></span></span><br><span class="line">  <span class="keyword">final</span> counter = CounterModel();</span><br><span class="line">  </span><br><span class="line">  runApp(</span><br><span class="line">    ChangeNotifierProvider.value(</span><br><span class="line">      notifier: counter,</span><br><span class="line">      child: MyApp(),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      theme: ThemeData.dark(),</span><br><span class="line">      home: FirstScreen(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们使用ChangeNotifierProvider，并设置其value为之前创建的数据模型。ChangeNotifierProvider<T>.value类型的数据，不仅可以将数据共享给其所有的子节点进行使用，同时还可以在数据发生变化时，通过调用之前数据模型中的notifyListeners()方法进行刷新。</p>
<p>第四步  在其他页面中获取共享的状态</p>
<p>这里我们通过两个页面，相互之间共同持有一份数据的例子，来看看Provider是怎么处理两个页面之间数据的共享的，首先我们创建第一个页面</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Provider 页面</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstScreen</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">  	<span class="built_in">print</span>(<span class="string">&quot;Provider &quot;</span> + <span class="string">&quot;FirstScreen build&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> _counter = Provider.of&lt;CounterModel&gt;(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(title: Text(<span class="string">&#x27;FirstPage&#x27;</span>)),</span><br><span class="line">      body: Center(</span><br><span class="line">          child: GestureDetector(</span><br><span class="line">              onTap: () =&gt; &#123;_counter.increment()&#125;,</span><br><span class="line">              child: Text(</span><br><span class="line">                <span class="string">&#x27;Value: <span class="subst">$&#123;_counter.value&#125;</span>&#x27;</span>,</span><br><span class="line">                style: TextStyle(fontSize: <span class="number">48</span>),</span><br><span class="line">              ))),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: () =&gt; Navigator.of(context)</span><br><span class="line">            .push(MaterialPageRoute(builder: (context) =&gt; SecondPage())),</span><br><span class="line">        child: Icon(Icons.navigate_next),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个页面中，我们使用Provider.of<T>(context)方法来向上寻找最近存储了T的祖先节点数据。我们这里获取到了存储的CounterModel，并对其属性value进行展示。然后在点击文本的时候，自增，希望在第二个页面中，可以拿到并展示。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Provider 页面</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext buildContext) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Provider &quot;</span> + <span class="string">&quot;SecondPage build&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">&#x27;Second Page&#x27;</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Consumer&lt;CounterModel&gt;(</span><br><span class="line">          builder: (context, CounterModel counter, _) =&gt; Center(</span><br><span class="line">              child: GestureDetector(</span><br><span class="line">                  onTap: () =&gt; &#123;counter.increment()&#125;,</span><br><span class="line">                  child: Text(</span><br><span class="line">                    <span class="string">&#x27;Value: <span class="subst">$&#123;counter.value&#125;</span>&#x27;</span>,</span><br><span class="line">                    style: TextStyle(</span><br><span class="line">                      fontSize: <span class="number">48</span>,</span><br><span class="line">                    ),</span><br><span class="line">                  ))),</span><br><span class="line">        ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第二个页面中，我们并没有像在第一个页面中一样，使用Provider.of<T>(context)方式去获取Provider中共享的数据，而是使用了Consumer这个方式去获取，这两个有什么不一样呢，先看完演示结果，然后继续往下分析。</p>
<h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>在上边的例子中，我们使用了Consumer获取Provider中共享的数据模型，Consumer使用了Builder模式，收到更新通知就会通过builder重新构建。Consumer<T>代表了它要获取哪一个祖先中的Model。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Widget <span class="built_in">Function</span>(BuildContext context, T value, Widget child) builder;</span><br></pre></td></tr></table></figure>

<p>从Consumer的构造方法中，我们可以看到，其builder实际上就是一个Funcation，它接受三个参数，用于构建自身。同样原理的还有Consumer2，和Consumer类似，只是入参的泛型，变成了两个：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Widget <span class="built_in">Function</span>(BuildContext context, A value, B value2, Widget child) builder;</span><br></pre></td></tr></table></figure>

<p>其实在源码中，这里最多可以到6个，大家在使用的过程中，可以根据自己需要进行选取。</p>
<p>那么为什么需要区分这两个获取数据类型的方法呢，我们在上述两个页面的build方法中，分别添加了log，进行日志打印，操作步骤为：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 进入第一个页面，点击两次Value，使数据自增</span><br><span class="line"><span class="number">2.</span> 点击进入下一个页面</span><br><span class="line"><span class="number">3.</span> 在第二个页面，同样点击两次Value，使数据自增</span><br><span class="line"><span class="number">4.</span> 返回第一个页面，点击一次Value，自增</span><br></pre></td></tr></table></figure>


<p>​	<br>我们可以看到Log打印如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-12</span><span class="number">-12</span> <span class="number">18</span>:<span class="number">30</span>:<span class="number">26.873</span> <span class="number">4273</span><span class="number">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br><span class="line"><span class="number">2020</span><span class="number">-12</span><span class="number">-12</span> <span class="number">18</span>:<span class="number">30</span>:<span class="number">27.777</span> <span class="number">4273</span><span class="number">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br><span class="line"><span class="number">2020</span><span class="number">-12</span><span class="number">-12</span> <span class="number">18</span>:<span class="number">30</span>:<span class="number">29.290</span> <span class="number">4273</span><span class="number">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider SecondPage build</span><br><span class="line"><span class="number">2020</span><span class="number">-12</span><span class="number">-12</span> <span class="number">18</span>:<span class="number">30</span>:<span class="number">30.203</span> <span class="number">4273</span><span class="number">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br><span class="line"><span class="number">2020</span><span class="number">-12</span><span class="number">-12</span> <span class="number">18</span>:<span class="number">30</span>:<span class="number">31.726</span> <span class="number">4273</span><span class="number">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br><span class="line"><span class="number">2020</span><span class="number">-12</span><span class="number">-12</span> <span class="number">18</span>:<span class="number">30</span>:<span class="number">35.223</span> <span class="number">4273</span><span class="number">-6507</span>/jd.com.state.flutter_state_manager I/flutter: Provider FirstScreen build</span><br></pre></td></tr></table></figure>

<p>可以看到使用Provider.of<T>(context)的第一个页面，在每一次点击按钮的时候，都会重新build，而页面二，则没有。也就是说，使用Consumer进行数据共享的时候，仅仅只更新自身的Widget。那么为什么Consumer可以做到局部更新呢，我们来看一下Consumer的内部构造：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> builder(</span><br><span class="line">      context,</span><br><span class="line">      Provider.of&lt;T&gt;(context),</span><br><span class="line">      child,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>也就是在Consumer中，实际上，也是通过使用Provider.of<T>(context),来实现的。那么问题就来了，同样是Provider.of<T>(context)实现的，为什么Consumer就可以实现局部刷新呢？</p>
<p>这里我们可以看一下在第二个页面中，我们在构建Consumer的时候，传递的context，并不是Widget中build方法提供的buildContext，而是使用了自己的context，所以在刷新的时候，可以做到局部刷新，这样就方便我们在Flutter开发的时候，使用局部刷新进行页面性能优化。</p>
<p><img src="http://image.jucaiwy.com/image/20220419/flutter_state_code.png"></p>
<p>至此，我们已经基本上了解到了Provider的基础用法，当然Provider还提供了核心的dispose方法，方便用户进行回收，这里因为还没有彻底搞清楚，所以暂不进行介绍。</p>
<p>Provider还有更多，更详尽的用法，比如 ValueListenableProvider、FutureProvider、StreamProvider等多种Provider，可见整个Provider的设计上更贴近Flutter的原生特性，同时设计也更好理解，并且兼顾了性能等问题。这些后边在使用到的时候，我们在进行逐步分析和解析</p>
<h3 id="五、-总结"><a href="#五、-总结" class="headerlink" title="五、 总结"></a>五、 总结</h3><p>总结上述所有的状态管理机制，无论是Flutter原生提供的Stream，还是ReactiveX提供的RxDart，亦或是Provider，以及没有在文章中出现的scoped_model、阿里开源的fish_redux，这一系列的组件，都为我们提供了一个很好的状态管理机制，而我们在使用过程中，大可通过自身业务需求，按需选型。</p>
<p>​	</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">沙僧</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/04/19/Flutter%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/">http://example.com/2022/04/19/Flutter%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">沙僧</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Flutter/">Flutter</a><a class="post-meta__tags" href="/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/">状态管理</a><a class="post-meta__tags" href="/tags/Provider/">Provider</a><a class="post-meta__tags" href="/tags/Stream/">Stream</a></div><div class="post_share"><div class="social-share" data-image="http://image.jucaiwy.com/image/20220419/flutter_state_cover.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2019/11/28/20191128Flutter%E2%80%94Json%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96/"><img class="next-cover" src="http://image.jucaiwy.com/image/20191128/flutter_json.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Flutter—Json数据格式化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/11/28/20191128Flutter%E2%80%94Json%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96/" title="Flutter—Json数据格式化"><img class="cover" src="http://image.jucaiwy.com/image/20191128/flutter_json.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-28</div><div class="title">Flutter—Json数据格式化</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="http://image.jucaiwy.com/favicon.ico" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">沙僧</div><div class="author-info__description">记录生活和学习</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/duanbokan"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/duanbokan" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:duanbokan@126.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">不负每一份热爱...</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Flutter%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">Flutter状态管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">一、 状态管理分类：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">局部状态：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-number">1.1.2.</span> <span class="toc-text">全局状态：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.3.</span> <span class="toc-text">最简单的状态管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E2%80%94%E2%80%94Stream"><span class="toc-number">1.2.</span> <span class="toc-text">二、 状态管理——Stream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%AE%A2%E9%98%85%E6%B5%81"><span class="toc-number">1.2.1.</span> <span class="toc-text">单订阅流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E6%B5%81"><span class="toc-number">1.2.2.</span> <span class="toc-text">广播流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StreamBuilder%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%B7%E6%96%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">StreamBuilder如何实现刷新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StreamController%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.4.</span> <span class="toc-text">StreamController整体架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StreamController%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="toc-number">1.2.5.</span> <span class="toc-text">StreamController同步、异步处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E2%80%94%E2%80%94RxDart"><span class="toc-number">1.3.</span> <span class="toc-text">三、状态管理——RxDart</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E2%80%94%E2%80%94Provider"><span class="toc-number">1.4.</span> <span class="toc-text">四、状态管理——Provider</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Provider%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">Provider使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Consumer"><span class="toc-number">1.4.2.</span> <span class="toc-text">Consumer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81-%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">五、 总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/19/Flutter%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/" title="Flutter状态管理"><img src="http://image.jucaiwy.com/image/20220419/flutter_state_cover.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Flutter状态管理"/></a><div class="content"><a class="title" href="/2022/04/19/Flutter%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A1%86%E6%9E%B6/" title="Flutter状态管理">Flutter状态管理</a><time datetime="2022-04-19T06:54:46.000Z" title="发表于 2022-04-19 14:54:46">2022-04-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2019/11/28/20191128Flutter%E2%80%94Json%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96/" title="Flutter—Json数据格式化"><img src="http://image.jucaiwy.com/image/20191128/flutter_json.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Flutter—Json数据格式化"/></a><div class="content"><a class="title" href="/2019/11/28/20191128Flutter%E2%80%94Json%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96/" title="Flutter—Json数据格式化">Flutter—Json数据格式化</a><time datetime="2019-11-28T06:54:46.000Z" title="发表于 2019-11-28 14:54:46">2019-11-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2018/01/04/20180104%E9%9B%86%E6%88%90ReactNative%E5%88%B0%E5%B7%B2%E6%9C%89%E5%B7%A5%E7%A8%8B/" title="AndroidStudio集成ReactNative到已有工程"><img src="http://image.jucaiwy.com/image/20180104/react_native.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AndroidStudio集成ReactNative到已有工程"/></a><div class="content"><a class="title" href="/2018/01/04/20180104%E9%9B%86%E6%88%90ReactNative%E5%88%B0%E5%B7%B2%E6%9C%89%E5%B7%A5%E7%A8%8B/" title="AndroidStudio集成ReactNative到已有工程">AndroidStudio集成ReactNative到已有工程</a><time datetime="2018-01-04T11:34:46.000Z" title="发表于 2018-01-04 19:34:46">2018-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2017/12/21/20171221IJKPlayer%E4%BD%BF%E7%94%A8SeekTo%E8%B7%B3%E8%BD%AC%E5%85%B3%E9%94%AE%E5%B8%A7%E4%B8%8D%E6%AD%A3%E7%A1%AE/" title="IJKPlayer使用SeekTo跳转关键帧不正确"><img src="http://image.jucaiwy.com/image/20161221/ijk_player.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IJKPlayer使用SeekTo跳转关键帧不正确"/></a><div class="content"><a class="title" href="/2017/12/21/20171221IJKPlayer%E4%BD%BF%E7%94%A8SeekTo%E8%B7%B3%E8%BD%AC%E5%85%B3%E9%94%AE%E5%B8%A7%E4%B8%8D%E6%AD%A3%E7%A1%AE/" title="IJKPlayer使用SeekTo跳转关键帧不正确">IJKPlayer使用SeekTo跳转关键帧不正确</a><time datetime="2017-12-21T09:56:53.000Z" title="发表于 2017-12-21 17:56:53">2017-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2017/12/11/20171211HEIF%E5%9B%BE%E7%89%87%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F%E6%8E%A2%E7%A7%98/" title="HEIF图片存储格式探秘"><img src="http://image.jucaiwy.com/image/20161211/heif_image.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HEIF图片存储格式探秘"/></a><div class="content"><a class="title" href="/2017/12/11/20171211HEIF%E5%9B%BE%E7%89%87%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F%E6%8E%A2%E7%A7%98/" title="HEIF图片存储格式探秘">HEIF图片存储格式探秘</a><time datetime="2017-12-11T10:30:43.000Z" title="发表于 2017-12-11 18:30:43">2017-12-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 沙僧</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my blog.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div></div></body></html>